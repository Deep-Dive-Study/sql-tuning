# 2장 인덱스 기본

# 2.1 인덱스 구조 및 탐색

## 2.1.1 미리 보는 인덱스 튜닝

### 데이터를 찾는 두 가지 방법

풀 스캔과 인덱스를 스캔하는 방법이 있다. 검색 대상이 많다면, 풀 스캔이 적다면 인덱스 스캔이 더 빠르다.

인덱스는 컬럼 - ROWID 쌍으로 이루어져 있다.

### 인덱스 튜닝의 두 가지 핵심 요소

OLTP 시스템에서는 소량 데이터를 주로 검색하므로 튜닝이 상당이 중요하다.

중요한 점은 인덱스 스캔 과정에서 나타나는 비효율과, 엑세스 횟수를 줄이는 것이다.

- 비효율 개선 (정렬 순서, 스캔 양 등)
- **엑세스 횟수 개선** (랜덤 I/O 최소화 등)

### SQL 튜닝은 랜덤 I/O와의 전쟁

- 데이터 성능이 느린 이유는 디스크 I/O 때문이다.
- 인덱스를 많이 사용하는 OLTP의 경우 디스크 I/O중 랜덤 I/O가 특히 중요하다
- 본질은 랜덤 I/O를 줄이는 것이다.

## 2.1.2 인덱스 구조

일반적으로 B*Tree를 사용한다.

![image](https://github.com/user-attachments/assets/74e8091a-32c3-49a5-9d3f-99a81af7bf01)

- 루트와 브랜치 블록은 각 하위 블록에 대한 주소를 갖는다. 키값은 하위 블록에 저장된 범위
- LMC : Leftmost Child 의 줄임말로 자식 노드중 가장 왼쪽에 있는 블록을 가리킴(루트, 브랜치에만 존재)
- 리프 블록에 저장된 레코드는 키값 순으로 정렬되어 있으며 ROWID를 갖는다.
- ROWID : 데이터 블록 주소 + 로우 번호
- 데이터 블록 주소 : 데이터 파일 번호 + 블록 번호
- 블록 번호 : 데이터파일 내에서 부여한 상대적 순번
- 로우 번호 : 블록 내 순번

## 2.1.3 인덱스 수직적 탐색

인덱스 스캔 시작지점을 찾는 과정이다.

1. 루트 블록부터 브랜치 블록에 저장된 하위 블록에 대한 주소값을 찾아 탐색한다.
2. 브랜치 블록에서 찾고자 하는 검색어보다 큰 키값 바로 앞 블록으로 간다.
3. 리프 블록을 찾는다.

## 2.1.4 인덱스 수평적 탐색

스캔 시작점으로부터 데이터를 찾는 과정이다.

1. 리프 블록은 연결 리스트이므로 시작점으로부터 순차 탐색을 하며 ROWID를 찾는다.

## 2.1.5 결합 인덱스 구조와 탐색

![image](https://github.com/user-attachments/assets/eb6ba8ac-237f-4539-bc39-f5085a16a416)

탐색 방법은 동일하다. 다만 여기서 인덱스 컬럼의 순서가 바뀌게 되면 탐색할 때 사용되는 I/O 개수가 달라진다.

→ 결합 인덱스는 생성되는 구조에 따라 성능이 다르다.

# 2.2 인덱스 기본 사용법

## 2.2.1 인덱스를 사용한다는 것

인덱스는 정렬되어있고, 비슷한 단어는 서로 모여있다.

단어를 찾기 위한 탐색 시작 블록을 찾지 못한다면, 처음부터 Index Full Scan을 하는 방법 밖에 없다.

→ 시작점을 어떻게 찾으면 될까?

## 2.2.2 인덱스 Range Scan 할 수 없는 이유

Index Range Scan : 인덱스 리프노드 시작점부터 스캔해서 중간에 멈추는 것

인덱스 컬럼을 가공하면 Range Scan을 할 수 없다. 모르면 외워라.

아래 방식으로 질의를 하게 되면, Scan 시작지점과 끝 지점을 모르기 때문에 Range Scan할 수 없다.

```sql
ex
WHERE column between '1234' and '5678' -> 인덱스 사용 가능
WHERE substr(column, 5, 2) = '05' -> 인덱스 사용 불가

LIKE column like '123%'; -> 인덱스 사용 가능
LIKE column like '%123%'; -> 인덱스 사용 불가

WHERE (column1 = '1' or column2 = '2') -> 인덱스 사용 불가
WHERE column1 IN ('1', '2') -> 인덱스 사용 불가 (OR절이라고 보면 됨)
-> UNION ALL을 사용하라
```

## 2.2.3 더 중요한 인덱스 사용 조건

인덱스 사용 선행 조건

- 결합 인덱스의 경우 선두 컬럼이 조건에 있어야 후행 컬럼도 인덱스를 사용하게 된다.
- 인덱스 컬럼이 가공되지 않은 상태로 조건절에 있어야 한다.

### 인덱스를 타면 튜닝이 끝인가?

테이블에 데이터량이 상당히 많은 경우 Range Scan을 하더라도 스캔하는 리프 블록의 개수가 많을 수 있다.

탐색 블록 개수도 확인하자

## 2.2.4 인덱스를 이용한 소트 연산 생략

인덱스는 데이터가 정렬되어 있어 일정 부분만 읽고 정지할 수 있는건데, 이를 활용할 수 있다.

![image](https://github.com/user-attachments/assets/bdf629c8-75ed-47dd-97c2-70a260e48ba0)

장비번호 + 변경일자 + 변경순번으로 이루어진 테이블이 있고, 아래 쿼리를 날렸다.

```sql
SELECT *
FROM 테이블
WHERE 장비번호 = 'C'
	AND 변경일자 = '20180316'
```

PK인덱스를 사용하면 결과 집합이 변경순번 순으로 출력된다. 따라서 옵티마이저는 ORDER BY 절이 있어도 수행하지 않고 결과를 반환한다.

내림차순 정렬에도 적용할 수 있다. (탐색 시작과 끝 순서를 바꿈)

만약 인덱스가 정렬되지 않았으면 생략할 수 없음

## 2.2.5 ORDER BY 절에서 컬럼 가공

조건절에서 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다.

게다가 ORDER BY 또는 SELECT-LIST에서 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없는 경우도 있다.

```sql
1
SELECT *
FROM 테이블
WHERE 장비번호 = 'C'
ORDER BY 변경일자 || 변경순번
;

2
SELECT TO_CHAT(A.column1, '1234') as column1 ->  Alias를 A.column1로 바꾸면 생략가능
FROM 테이블
WHERE 장비번호 = 'C'
ORDER BY A.column1
```

만일 이런 쿼리를 작성했으면 정렬을 생략할 수 없다.

1번 쿼리는 ORDER BY 조건이 가공한 값 기준이어서, 2번 쿼리는 반환 값이 가공되어서이다.

## 2.2.6 SELECT-LIST에서 컬럼 가공

인덱스가 [장비번호 + 변경일자 + 변경순번] 순으로 구성되면 아래 쿼리에도 정렬 연산을 따로 수행하지 않는다.

```sql
-- 수직 탐색 좌측 첫 번째 값을 읽는다. (MAX는 우측 첫 번째)
SELECT MIN(변경순번)
FROM 상태변경이력
WHERE 장비번호 = 'C'
	AND 변경일자 = '20180316'
	
-- 정렬 연산을 생략할 수 없다. 
SELECT NVL(MAX(TO_NUMBER(변경순번)), 0)
FROM 상태변경이력
WHERE 장비번호 ='C'
	AND 변경일자 = '20180316'
-- INDEX를 가공하기 떄문이다. NVL(TO_NUMBER(MAX(변경순번)),0) 이면 된다.

-- 스칼라 쿼리에서도 수직 탐색 첫 번째 값을 읽음
SELECT 장비번호, 장비명, 상태코드, 
	(SELECT MAX(변경일자)
	FROM 상태변경이력
	WHERE 장비번호 = P.장비번호) AS 최종변경일자
FROM 장비 P
WHERE 장비구분코드 = 'A001'
```

SQL을 작성할 때 PK 컬럼이 많아지면 SQL이 복잡해지므로 성능도 나빠진다.

```sql
SELECT 장비번호, 장비명, 상태코드
	,(SELECT MAX(변경일자)
	FROM 상태변경이력
	WHERE 장비번호 = P.장비번호) AS 최종변경일자
	,(SELECT MAX(변경순번)
	FROM 상태변경이력
	WHERE 장비번호 = P.장비번호
	AND 변경일자 = (SELECT MAX(변경일자)
								FROM 상태변경이력
								WHERE 장비번호 = P.장비번호)) AS 최종변경순번
FROM 장비 P
WHERE 장비구분코드 = 'A001'

-- 덜 복잡하지만 성능이 매우 나빠지는 쿼리
-- 원인은 인덱스 레코드를 가공했기 때문이다.
SELECT 장비번호, 장비명, 상태코드
	,SUBSTR(최종이력, 1, 8) AS 최종변경일자
	,SUBSTR(최종이력, 9) AS 최종변경순번
FROM (
	SELECT 장비번호, 장비명, 상태코드
		,(SELECT MAX(변경일자 || 변경순번)
		FROM 상태변경이력
		WHERE 장비번호 = P.장비번호) AS 최종이력
	FROM 장비 P
	WHERE 장비구분코드 = 'A001'
)
```

## 2.2.7 자동 형변환

![Uploading image.png…]()

옵티마이저가 자동으로 생년월일 조건을 TO_NUMBER로 형변환 하여 인덱스를 사용하지 못했다.

각 조건절에서 양쪽 값 타입이 다르면 비교할 수 없기 때문에 오라클은 이렇게 형변환을 한다.

→ 원하는 실행 계획대로 실행되지 않음 / 결과 집합이 달라질 수 있음

- 숫자형이 문자형보다 강하다.
- 날짜형이 문자형보다 강하다.
- LIKE 연산자에선 문자형이 강하다.

**동적 쿼리를 위해 LIKE 조건 사용**

```sql
SELECT * FROM 거래
WHERE 계좌번호 =?
	AND 거래일자 between ? AND ?

-> 동적쿼리 만들기
 
SELECT * FROM 거래
WHERE 계좌번호 LIKE ? || '%'
	AND 거래일자 between ? AND ?	
```

위와 같이 동적쿼리를 생성하면, 자동 형변환으로 인해 인덱스 조건으로 사용할 수 없게 된다.

### 자동 형변환 주의

자동 형변환의 단점

- 변환 오류가 발생할 수 있다.
- 결과 오류가 발생할 수 있다. (decode 규칙)

형변환 함수를 생략한다 해서 성능에 변화는 없다. 블록 I/O를 줄일 방법을 찾아야 한다.
