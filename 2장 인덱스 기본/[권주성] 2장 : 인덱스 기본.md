# 2장. 인덱스 기본

## 2.1 인덱스 구조 및 탐색
- 인덱스의 탐색 과정은 `수직적 탐색`과 `수평적 탐색` 단계로 이루어져 있음

### 2.1.1 미리 보는 인덱스 튜닝

#### 데이터베이스 테이블에서 데이터를 찾는 방법
- 테이블 풀 스캔
- 인덱스 이용

- 전체를 다 확인할 것인지, 혹은 특정 영역만 확인할 것인지
  - 찾아야 하는 영역이 많으면 전체를 찾는 것이 효율적일 수 있음
  - 서비스(도메인)의 데이터 특징을 올바르게 이해하는 것이 중요할 듯 (설계의 기본 방향)

- 테이블 전체를 찾는 것은 따로 튜닝을 할만한 요소가 적은 반면에, 인덱스와 관련해서는 튜닝 요소가 매우 많고 기법도 다양함

#### 인덱스 튜닝의 핵심 요소
- **`인덱스 스캔 효율화 튜닝`**
  - 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것 
- **`랜덤 액세스 최소화 튜닝`**
  - 테이블 액세스(I/O) 횟수를 줄이는 것 

  ![CleanShot 2024-07-17 at 21 43 30](https://github.com/user-attachments/assets/9d170f13-2be9-47bd-aa59-d4346d92b251)

- 둘다 중요하지만, **`랜덤 액세스 최소화 튜닝`** 이 조금 더 중요함(성능에 미치는 영향이 더 큼)
  - DBMS가 제공하는 대부분의 기능이 느린 랜덤 I/O를 극복하기 위해 개발됨
  - 그만큼 SQL 튜닝은 랜덤 I/O와의 전쟁이라고 볼 수 있음

### 2.1.2 인덱스 구조
- 보통 DBMS의 인덱스는 B(Balanced)*Tree 자료구조로 구현되어 있으며, 정렬되어 있음
  - 즉, 범위 스캔(Range Scan)이 가능함 → 데이터 일부만 읽고 멈출 수 있음

  ![CleanShot 2024-07-17 at 21 48 33](https://github.com/user-attachments/assets/eea89590-63c8-4d7f-931c-0667ae24f91f)

#### **B*Tree 구성**
- `루트 노드(Root)`
- `브랜치 노드(Branch)`
- `리프 노드(Leaf)`

#### **루트와 브랜치 블록의 구성**
- 각 레코드는 `하위 블록에 대한 주소값을 가짐`
- key 값을 가지고, 키 값은 `하위 블록에 저장된 키 값의 범위`를 나타냄
- LMC(Left Most Child) : 가장 왼쪽에 위치한 블럭을 가리킴
  - 첫 번째 키값을 가진 레코드보다 작거나 같은 레코드가 저장

#### **리프 블록의 구성**
- `정렬된 key 값`
- 각 key 값은 `테이블 레코드를 가리키는 주소값(ROWID)`
  - ROWID : DBA(Data Block Address) + 로우 번호
  - 즉, 데이터 파일 번호 + 블록 번호 + 로우 번호

#### **수직적, 수평적 탐색**
- 수직적 탐색: 인덱스 스캔 시작 시점을 찾는 과정
- 수평적 탐색: 데이터를 찾는 과정

### 2.1.3 인덱스 수직적 탐색
- **`조건을 만족하는 첫 번째 레코드(시작점)를 찾는 과정`**
  - 찾고자 하는 값 보다 크거나 같은 레코드(key)를 찾으면 그 직전 레코드가 가리키는 하위 블록으로 이동
  - 찾고자 하는 값과 같은 레코드를 찾아도 **그 직전 레코드가 가리키는 하위 블록으로 가야 조건을 만족하는 '첫번째' 블록을 찾을 수 있음**

### 2.1.4 인덱스 수평적 탐색
- **`실제 데이터를 찾는 과정`**
  - 리프 블록에서 수평적으로 탐색하면서 찾고자 하는 데이터가 더 안나타날 때까지 스캔
  - 인덱스 리프는 더블 링크드 리스트 구조
    - 따라서, 거꾸로(좌,우 방향)도 찾을 수 있음
  - 조건절을 만족하는 데이터를 찾고, 필요한 컬럼이 더 있는 경우 테이블을 엑세스함

### 2.1.5 결합 인덱스 구조와 탐색
- **`결합 인덱스`**
  - 두 개 이상의 컬럼을 결합해서 인덱스를 만드는 것

- 인덱스를 (고객명, 성별)로 구성하든, (성별, 고객명)으로 구성하든 읽는 인덱스 블록 개수는 똑같음
- 따라서, where에서 '=' 조건 검색할 때는 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O 개수가 같음(즉, 성능이 동일)

- **`인덱스 구성에 따라 성능 차이가 나는 것은 맞지만, 엑셀의 필터와는 다름`**
  - B*Tree 인덱스는 엑셀과 달리 평면 구조가 아님 

  ![CleanShot 2024-07-17 at 21 59 33](https://github.com/user-attachments/assets/011cbeda-fe92-4910-a209-3c249f994600)

## 2.2 인덱스 기본 사용법
- 인덱스의 기본 사용법은 Index Range Scan하는 방법을 의미

### 2.2.1 인덱스를 사용한다는 것
- **`Index Full Scan`** vs **`Index Range Scan`**
  - 일반적으로 인덱스를 정상적으로 사용한다는 것은 **`Index Range Scan`** 을 의미

- 즉, 리프 블록에서 스캔 시작점을 찾아서 중간에 멈추는 지점을 찾아 멈추는 것

### 2.2.2 인덱스 Range Scan 할 수 없는 이유
- 인덱스 컬럼(정확히는 선두 컬럼)을 가공하거나 인덱스의 중간에 포함된 값으로 색인을 하고자 하는 경우에는 Index Range Scan이 불가능함
  - 인덱스를 통해 데이터를 Range Scan할 수 있는 이유가 정렬이 되어 있기 때문
  - 따라서, 데이터가 정렬된 상태가 아닌 경우에는 범위를 한정지을 수 없음(`시작점과 끝점을 찾을 수 없는 경우`)

      ![CleanShot 2024-07-17 at 22 11 50](https://github.com/user-attachments/assets/e029b5d4-104f-4605-ad9d-b31ef4333a8a)

- or이나 in 절로 검색하는 경우에도 Index Range Scan이 불가능하지만, 옵티마이저의 쿼리 변환 기능을 통해 여러 개의 Index Range Scan으로 처리되기도 함(`OR Expansion`)

### 2.2.3 더 중요한 인덱스 사용 조건
- 인덱스 Range Scan을 하기 위해서는 반드시 **인덱스 선두 컬럼**이 **가공되지 않은 상태로** 조건절에 있어야 함
  - 그렇다면 무조건 Range Scan은 가능함 (어디서 시작해서 어디서 끝나는지를 특정할 수 있는 경우)

- 다만, 인덱스를 잘 탄다고 해서 항상 성능이 좋은 것은 아님(즉, 튜닝을 더 할 수 있을 수도 있음)
  - 인덱스 리프 블록에서 스캔하는 양을 따져봐야 알 수 있음

### 2.2.4 인덱스를 이용한 소트 연산 생략
- 인덱스는 정렬된 상태로 저장되어 있음
  - order by 연산을 생략할 수 있음

- `오름차순의 경우` : 조건을 만족하는 가장 작은 값부터 왼쪽에서 오른쪽으로 스캔함
- `내림차순의 경우` : 조건을 만족하는 가장 큰 값인 오른쪽에서부터 왼쪽으로 스캔함

### 2.2.5 ORDER BY 절에서 컬럼 가공
- 간혹, 조건절이 아닌 ORDER BY 또는 SELECT-LIST에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우가 있음

```sql
select *
  from (
    select to_char(a.주문번호, ‘FM000000’) as 주문번호, a.업체번호, a.주문금액
      from 주문 a
    where a.주문일자 =: dt and a.주문번호 > NVL(:next_ord_no, 0)
    order by 주문번호
    ) 
where rownum < = 30`
```

→ order by 절에 사용된 주문번호는 to_char로 가공된 주문번호 → sort 가 일어나게됨. 따라서, a.주문번호로 바꿔주면 sort 생략가능

### 2.2.6 SELECT-LIST에서 컬럼 가공

`SELECT MIN(변경순번) FROM 상태변경이력 WHERE 장비번호 = 'C' AND 변경일자 = '20180316'`

`SELECT MAX(변경순번) FROM 상태변경이력 WHERE 장비번호 = 'C' AND 변경일자 = '20180316'`

- 인덱스를 이용해 정렬 연산 없이 최소, 최대값을 빠르게 찾을 수 있다
  - 실행계획에는 INDEX RANGE SCAN (MIN/MAX) 상태변경이력_PK, FIRST ROW라고 뜸

  ![CleanShot 2024-07-17 at 22 30 01](https://github.com/user-attachments/assets/a610ed2d-d8e4-46ba-ac3c-0ef77a742304)

`SELECT NVL(MAX(TO_NUMBER(변경순번)), 0) FROM 상태변경이력 WHERE 장비번호 = 'C' AND 변경일자 = '20180316'`

→ 이런식으로 짜면 인덱스 컬럼에 수정이 생기므로 정렬 연산을 줄일 수 없다

⇒ `SELECT NVL(TO_NUMBER(MAX(변경순번)), 0) FROM 상태변경이력 WHERE 장비번호 = 'C' AND 변경일자 = '20180316'`로 수정 가능

- 서브 쿼리에서 사용할 경우도 마찬가지

```sql
SELECT 장비번호, 장비명, 상태코드
        , (SELECT MAX(변경일자))
        FROM 상태변경이력
        WHERE 장비번호 = P.장비번호) 최종변경일자
        , (SELECT MAX(변경순번)
        FROM 상태변경이력
        WHERE 장비번호 = P.장비번호
        AND 변경일자 = (SELECT MAX(변경일자)
                        FROM 상태변경이력
                        WHERE 장비번호 = P.장비번호)) 최종변경순번
FROM 장비 P
WHERE 장비구분코드 = 'A001'
```

### 2.2.7 자동 형변환
- 조건절에서 입력되는 데이터 타입과 실제 테이블 타입이 다르면 컴파일 시점에 에러를 내는 DBMS도 있고 Oracle처럼 형변환해주는 DBMS도 있음
  - 인덱스 컬럼에 자동 형변환이 걸리면 인덱스 사용이 불가능하거나, 효율이 떨어지므로 주의해야함

- 자동 형변환에 의존하지말고 명시적으로 형변환 해주는 것이 좋음(TO_CAHR, TO_DATE, TO_NUMBER)
  - 생략해도 옵티마이저가 자동으로 생성하기 때문에 연산 횟수에는 변함 없음 
