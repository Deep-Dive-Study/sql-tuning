# 4장 조인 튜닝

# 4.1 NL 조인

NL 조인은 인덱스를 이용한 조인이다.

## 4.1.1 기본 메커니즘

![image](https://github.com/user-attachments/assets/9970340a-3a80-4b8f-ad3c-478661eba90d)

1. 드라이빙 테이블에서 레코드를 찾는다.
2. 1번 데이터를 드리븐 테이블에서 찾는다.
3. 건바이건으로 1~2 반복

드라이빙, 드리븐 테이블의 인덱스를 모두 이용한다. (사이즈가 작으면 Full Table Scan 해버림)

## 4.1.2 NL 조인 실행계획 제어

```jsx
0		SELECT STATEMENT Optimizer=ALL_ROWS
1	0		NESTED LOOPS
2	1			TABLE ACCESS (BY INDEX ROWID) OF '사원' (TABLE)
3	2				INDEX (RANGE SCAN) OF '사원X1' (INDEX)
4	1			TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE)
5	4				INDEX (RANGE SCAN) OF '고객_X1' (INDEX)
```

힌트

- use_nl (테이블) : 괄호 안의 테이블이 드리븐 테이블일 떄 NL조인을 사용한다.
- ordered : FROM절에 기술한 순서대로 조인하도록 지시
- use_hash (테이블) : 괄호 안의 테이블이 드리븐 테이블일 떄 해시조인을 사용한다.

## 4.1.3 NL조인 수행 과정 분석

![image](https://github.com/user-attachments/assets/7d1931a0-1d1d-4443-8135-6b73c3069f43)

비교 순서 : 2 - 3 - 1 - 4

실행 계획

![image](https://github.com/user-attachments/assets/8fbb9b46-d7bb-4ce3-815e-371f95d97de9)

1. (2) 입사일자를 사원_X1 인덱스를 Range Scan한다.
2. (3) 1에서 얻은 ROWID로 테이블에 액세스해서 부서코드 필터링을 한다.
3. (1) 2에서 얻은 사원번호 값으로 고객쪽 레코드를 고객_X1 인덱스로 Range Scan 한다.
4. (4) 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블을 액세스해서 최종주문금액을 필터링한다.

![image](https://github.com/user-attachments/assets/e7ac3be3-c42a-4d86-bd99-cb47334a996f)

## 4.1.4 NL 조인 튜닝 포인트

튜닝 포인트

- 사원_X1 인덱스 이후 테이블에 액세스 할 때 (13, 21, 3, 25, 23) → 랜덤 액세스임
- 고객_X1 인덱스 탐색 부분 (5, 7, 9, 11, 27 ..) → 수평 스캔 과정에서 블록 I/O 많을 수 있음
- 고객_X1 인덱스 이후 테이블에 액세스 할 때 (6, 8, 28, 10 …) → 랜덤 액세스임

**올바른 조인 메소드 선택**

- OLTP는 NL조인부터 고려하라.
- 성능이 느리다면 랜덤 액세스, 조인 순서 순으로 튜닝 포인트를 잡아라.
- NL 조인으로 안된다 판단되면 소트머지 조인 또는 해시조인을 검토하라.

## 4.1.5 NL 조인 특징 요약

- 랜덤 액세스 위주의 조인 방식 (대용량 데이터에서 비효율 존재)
- 한 레코드씩 순차적 진행 (느려도 빠른 응답 가능)
- 인덱스 구성 전략이 매우 중요하다.
- OLTP 시스템에 적합하다.

## 4.1.6 NL 조인 튜닝 실습

쿼리

![image](https://github.com/user-attachments/assets/fec287da-b375-4950-a656-d4df18515821)

### 1번 케이스 (랜덤 액세스)

트레이스

![image](https://github.com/user-attachments/assets/6a0be8c6-9846-482b-9e1a-99ea4273f6d1)

테이블 액세스 횟수가 2780인데, 필터링 결과는 세 건에 그친다.

이런 경우 인덱스에 테이블 필터 조건 컬럼을 추가하는 것을 고려하라.

### 2번 케이스 (일량 확인)

트레이스

![image](https://github.com/user-attachments/assets/51a4659c-47a4-4819-adb8-f2a4f069833c)

테이블 액세스가 현저히 줄어들었지만, 인덱스 스캔 단계에서 일량이 확인되지 않는다.

`e.입사일자 >= '19960101'` 에 해당하는 레코드가 아주 많다면 `e.부서코드 = 'Z123'` 조건을 필터링 했을거지만, 어떻게 될지는 스캔 후 출력 건수를 따로 확인해야 한다.

![image](https://github.com/user-attachments/assets/b0456118-2cb6-4bf8-84eb-8668f4d0ca3b)

* cr : 논리적인 블록 요청 횟수 / pr : 디스크에서 읽은 블록 수 / pw : 디스크에 쓴 블록 수

사원_X1 인덱스로부터 읽은 블록이 100개가 넘는다. → 3개를 얻기 위해 50,000개 탐색

방법은 인덱스에 컬럼 순서를 (부서코드, 입사일자)로 조정한다.

### 3번 케이스 (조인 순서)

트레이스

![image](https://github.com/user-attachments/assets/900286c2-50d0-42bb-ac89-6af2e54bcdf9)

고객 테이블과 조인하는 횟수가 너무 많다. 최종주문금액 조건절에 부합하는 레코드가 별로 없다면 순서를 변경해보자.

순서를 변경해도 큰 변화가 없다면 소트/해시 조인을 고려해보자.

## 4.1.7 NL 조인 확장 메커니즘

NL조인 성능을 위해 Prefetch, 배치 I/O 기능이 있다.

* Prefetch : 인덱스를 이용해 테이블 액세스를 하다가 디스크 I/O가 필요해지면 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재

![image](https://github.com/user-attachments/assets/e3e33d92-9c8d-4183-a091-ce2a67ae97a3)

* 배치 I/O : 디스크 I/O를 미뤘다가 일정량이 쌓이면 한 번에 처리

![image](https://github.com/user-attachments/assets/e416a0fe-ae93-4385-abb2-ec5466ea0814)

오라클 11g에선 위의 실행계획이 모두 나타나는데, Inner 테이블 블록을 모두 버퍼캐시에서 읽으면 성능은 동일하다.

디스크에서 읽게 되는 순간 성능차이가 발생하고, 배치 I/O는 정렬 순서를 보장하지 않는다.

따라서 인라인 뷰에서 정렬 후 한 건씩 NL 조인 하도록 해서 정렬 순서를 보장하기도 한다.

# 4.2 소트 머지 조인

소트 머지 조인은 대량의 데이터를 다룰 때 해시 조인을 사용할 수 없으면 선택한다.

## 4.2.1 SGA vs PGA

![image](https://github.com/user-attachments/assets/ef4869ee-c305-4651-bb43-d97df583f6eb)

SGA : 공유 메모리 영역

- 동시에 한 프로세스만 접근 가능
- 락과 래치 사용
- DB 버퍼 캐시가 핵심 요소

PGA : 각 오라클 서버에 할당된 메모리 영역

- 독립적인 공간이므로 래치 불필요
- SGA 버퍼캐시보다 훨씬 빠르다.

## 4.2.2 기본 메커니즘

소트 머지 조인 순서

1. 소트 단계 : 양쪽 집합을 조인 컬럼을 기준으로 정렬
2. 머지 단계 : 정렬한 양쪽 집합을 서로 머지 한다.

### 과정

![image](https://github.com/user-attachments/assets/1a3d6508-0a52-4824-ae9f-3b082c470bd0)

use_merge() 힌트를 통해 소트 머지 조인을 유도한다.

1. 소트
- 사원 테이블 데이터를 읽어 사원번호 순으로 정렬한다.
- 정렬된 결과는 PGA의 Sort Area에 저장된다. (너무 크면 Temp 스페이스)

![image](https://github.com/user-attachments/assets/9b56b0d8-d007-4046-a50a-b6d695e79e9e)

1. 소트2
- 고객 테이블 데이터를 읽어 관리사원번호 순으로 정렬한다.
- 정렬된 결과는 PGA의 Sort Area에 저장된다. (너무 크면 Temp 스페이스)

1. 저장한 사원 데이터를 스캔하면서 PGA에 저장한 고객 데이터와 조인한다.

![image](https://github.com/user-attachments/assets/0b6feaa1-d613-44ea-9658-4d2fc61cadd3)

주목할 점은, 사원 데이터를 기준으로 고객 데이터는 매번 Range Scan한다. (인덱스가 없어도 가능)

## 4.2.3 소트 머지 조인이 빠른 이유

NL 조인과 비교해서 소트 머지 조인이 빠른 이유

- NL조인은 인덱스를 이용해서 **건건이** DB 버퍼캐시 경우 (래치 있음)
- 소트 머지 조인은 일괄로 읽고 PGA에 저장 후 처리 (래치 없음)
- 따라서 대량 데이터 조인에 더 빠름

## 4.2.4 소트 머지 조인의 주용도

대부분 해시 조인이 더 빨라서 잘 쓰이지 않음

소트 머지 조인이 더 빠를 때

- 해시 조인을 못쓸 때 (조인 조건이 = 이 아닐 때)
- 조인 조건식이 없는 조인 (Cross Join)

## 4.2.5 소트 머지 조인 제어하기

![image](https://github.com/user-attachments/assets/287a2ddf-722a-41c6-8e4a-acb159d34412)

인덱스를 이용해 소트 대상을 찾고, 소트 후 머지한다.

힌트는 use_merge(테이블)

## 4.2.6 소트 머지 특징 요약

- 실시간으로 인덱스를 생성하는 것과 다름 없음
- 정렬 이후 NL 조인 사용
- PGA 영역을 사용해서 빠르다.
- 조인 컬럼 인덱스의 영향을 받지 않는다.

# 4.3 해시 조인

## 4.3.1 기본 메커니즘

1. Build 단계 : 작은 쪽 테이블을 읽어 해시 테이블을 생성한다.
2. Probe 단계 : 큰 쪽 테이블을 읽어 해시 테이블을 탐색하며 조인한다.

### 과정

1. Build
- 해시 함수를 통해 해시 맵을 생성한다.
- 키 값은 조인컬럼이 된다.
- 반환된 해시 테이블은 PGA 영역의 Hash Area에 저장된다. (너무 크면 Temp)

1. Probe
- 작은쪽 해시 테이블음 탐색해 해시 체인을 찾는다.
- 조인될 테이블을 해시함수에 입력해 해시 체인을 찾고, 해시 체인을 스캔해서 조인조건을 만족시킨다.

![image](https://github.com/user-attachments/assets/ea4147ec-c4d6-4c92-a49e-73174431cc85)

해시 테이블을 사용하는 것을 제외하면 해시 테이블과 같다.

## 4.3.2 해시 조인이 빠른 이유

- PGA 영역 사용 (래치 사용 안함)
- 양쪽 집합 모두 정렬이 아닌, 작은 한 집합만 해시 맵을 만든다. (PGA 공간 절약)

## 4.3.3 대용량 Build Input 처리

양 테이블 모두 대용량 테이블인 경우 **분할 정복**을 한다.

1. 파티션 단계 : 양쪽 집합의 조인 컬럼에 해시 함수를 적용하고 결과에 따라 파티셔닝을 한다.

![image](https://github.com/user-attachments/assets/0ddb49bb-8e20-4563-9980-f822038bcdc8)

1. 조인 단계 : 파티션 짝 별로 조인을 수행한다.

## 4.3.4 해시 조인 실행계획 제어

실행 계획

![image](https://github.com/user-attachments/assets/520f5464-c401-41e1-8121-9eb744007f44)

힌트는 use_hash(테이블)

일반적으로 옵티마이저는 카디널리티가 작은 테이블을 Build Input으로 선택한다.

### 세 개 이상 테이블 해시 조인

조인하는 경로는 결국 한 가지다. 단 leading하는 테이블의 순서는 달라진다.

순서 제어를 위해 leading(A, B, C)를 사용한다.

- A는 무조건 Build Input이 된다.
- A,B의 결과물 또는 C가 Build Input이 된다.
- Build Input 제어는 swap_join_inputs / no_swap_join_inputs로 한다.
- 세 개가 아닌 그 이상의 조인에도 똑같은 원리를 적용한다.

## 4.3.5 조인 메서드 선택 기준

![image](https://github.com/user-attachments/assets/9aee3170-781c-457f-9a03-4ed1d1d9d066)

* 대량의 기준은 랜덤 액세스가 많은 경우, 성능이 안나오는 경우

수행 빈도가 매우 높은 쿼리의 경우

1. NL 조인과 해시 조인 성능이 같으면 → NL 선택
2. 해시가 좀 더 빨라도 → NL 선택
3. NL 조인보다 해시 조인이 매우 빠르면 → 해시 선택

NL조인을 가장 먼저 고려하는 이유

- NL 조인에 사용되는 인덱스는 영구적으로 유지된다.
- 반면에 해시 조인에 사용되는 해시 테이블은 일회성으로 사용되고, 소멸된다. (CPU, 메모리)
- 해시 테이블을 만들 때 래치 경합이 발생한다.

보통 수행 빈도가 낮고, 수행 시간이 오래걸리고, 대량일 때 해시 조인을 사용한다. (배치)

# 4.4 서브쿼리 조인

옵티마이저가 서브쿼리에 대해 다양한 형태로 쿼리 변환을 시도하므로 서브쿼리 조인에 대한 이해는 쿼리 변환에서 찾아야 한다.

## 4.4.1 서브쿼리 변환이 필요한 이유

옵티마이저는 실행계획을 세우기 앞서 사용자로부터 전달받은 SQL을 최적화에 유리한 형태로 변환을 진행한다.

쿼리 변환은 옵티마이저가 SQL을 분석해 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것을 말한다.

→ 쿼리 변환 솔루션이 있나? 튜닝할 때 전 후 집합 비교가 안되서 불안함

서브쿼리 : 하나의 SQL 문 안에 괄호로 묶은 별도의 쿼리 블록

![image](https://github.com/user-attachments/assets/5053b3d7-8405-426c-9d2f-2191984b88d6)

1. 인라인 뷰 : FROM 절에 사용한 서브쿼리
2. 중첩된 서브쿼리 : 결과집합을 한정하기 위해 WHERE 절에 사용한 서브쿼리. (서브쿼리가 메인쿼리 컬럼을 참조하는 형태를 **상관관계** 있는 서브쿼리라고 함)
3. 스칼라 서브쿼리 : 한 레코드당 정확히 하나의 값을 반환하는 서브쿼리. 주로 SELECT에서 사용

**옵티마이저는 쿼리 블록 단위로 최적화를 한다.**

![image](https://github.com/user-attachments/assets/a35ca96e-030f-4d66-895e-648846f736c2)

이렇게 최적화를 하는 것보다. 서브쿼리 부터 최적화 하는 것이 중요하다.

## 4.4.2 서브쿼리와 조인

메인쿼리와 서브쿼리 간에는 부모와 자식이라는 종속적이고 계층적인 관계가 존재한다.

따라서 메인 쿼리 건수만큼 값을 받아 반복적으로 필터링하는 방식으로 실행해야 한다.

### 필터 오퍼레이션

필터 오퍼레이션은 기본적으로 NL 조인과 처리 루틴이 같다.

차이점

1. 필터는 메인쿼리의 한 로우가 서브쿼리의 한 로우와 조인에 성공하는 순간 진행을 멈추고, 메인쿼리의 다음 로우를 계속 처리한다는 점이다.
    
    ![image](https://github.com/user-attachments/assets/5c2a3658-8c97-4b9e-9ee8-d7a822d5d5e1)

    ![image](https://github.com/user-attachments/assets/44a7ebd0-1991-4ab2-bba5-babb70a9b2ef)
    
2. 필터는 서브쿼리 입력 값에 따른 반환 값 캐싱 기능이 있다. (쿼리 단위로 PGA 이용)

### 서브쿼리 Unnesting

Unnesting : 중첩된 쿼리의 계층을 풀어 같은 레벨로 만드는 것. 서브쿼리 필터링이라고도 한다.

서브쿼리 필터링을 하게되면 여러가지 최적화 기법을 사용할 수 있다.

**ROWNUM**

ROWNUM은 쿼리 속도를 높이는데 아주 효괒거이다.

Exists같이 조건절을 만족하면 멈추는 쿼리에 ROWNUM을 추가하면 오히려 악효과를 줄 수 있다.

- 이미 Exists와 ROWNUM의 의미는 중복이다.
- Unnesting해도 ROWNUM은 남는다.
- 옵티마이징에 차질을 줄 수 있다.

### 서브쿼리 Pushing

Pushing : 서브쿼리 필터링을 가능한 앞에서 처리하도록 강제한다.

Unnesting 되지 않은 서브쿼리는 항상 필터 방식으로 처리되며, 대개 맨 마지막에 처리된다.

→ 서브쿼리의 조건으로 조인 조건을 없엘 수 없음.

push_suq : Pushing 제어 (Unnesting 되지 않은 경우에만 작동, no_unnest와 같이 사용)

no_push_suq : Pushing 제어 (Unnesting 되지 않은 경우에만 작동)

## 4.4.3 뷰와 조인

최적화 단위가 쿼리 블록이므로 옵티마이저가 뷰 쿼리를 변환하지 않으면 뷰 쿼리 블록을 독립적으로 최적화한다.

![image](https://github.com/user-attachments/assets/ee236d16-d80b-4749-b91b-a692ea227860)

뷰 쿼리 블록을 독립적으로 최적화 하면 조인을 이후에 한다.

문제는 메인 쿼리의 WHERE 절의 필터링 조건은 뷰 바깥에 있어 뷰 쿼리 블록을 최적화 할 때 대상이 되지 않는다.

힌트를 통해 뷰 쿼리와 Merge 하게 된다면, 조인할 때 메인 쿼리의 WHERE 절의 필터링이 된 상태에서 조인한다.

→ 이는 단점이 하나 있는데 Group By를 하고서야 데이터를 출력할 수 있다. (부분범위 처리가 불가능하다.)

### 조인 조건 Pushdown

Pushdown : 메인 쿼리를 실행하면서 조인 조건절 값을 건건이 뷰 안으로 밀어 넣는 기능

실행계획의 `PUSHED PREDICATE` 오퍼레이션을 통해 이 기능의 작동 여부를 알 수 있다.

`PUSHED PREDICATE` 오퍼레이션이 있다면, 뷰 내부에 조인 조건절을 넣어서 처리하게 최적화한다.

이후 뷰 쿼리 블록 내부의 Group by를 건건이 처리한다.

* 뷰를 조인할 때 힌트를 보려면 no_merge 힌트를 같이써야 한다.

* 인라인 뷰를 LATERAL로 선언하면 인라인 뷰에서 메인쿼리 테이블의 컬럼을 참조할 수 있다.

* Outer Apply 조인도 LATERAL과 같은 역할이다. (쓸일이 거의 없음)

## 4.4.4 스칼라 서브쿼리 조인

### 1. 스칼라 서브쿼리 특징

- SELECT 쿼리 건수만큼 반복 실행
- 한 번에 Null or 한 건만 반환한다.

### 2. 스칼라 서브쿼리 캐싱 효과

- 조인 횟수 최소화를 위해 입/출력 값을 내부 캐시에 저장해 둔다. (PGA)
- 호출 횟수 최소화 (사용자 정의 함수를 사용한다. → 캐싱 활용 극대화)

### 3. 스칼라 서브쿼리 캐싱 부작용

- 메모리 공간 부족
- 해시 충돌이 잦으면 비효율적이다.
- 스칼라 캐싱을 잘 활용하지 못하면 비효율적이다. (당연한 소리지만 조인되는 컬럼 카디널리티가 중요하다.)
- 함수 호출 횟수를 줄일 때 인풋 카디널리티가 높으면 비효율적이다.
- 메인 쿼리 집단이 너무 작아도 비효율 적이다. (캐싱 활용 못함)

### 4. 두 개 이상의 값 반환

스칼라 서브쿼리로 두 개 이상의 값을 반환하고 싶을 때

- 스칼라 쿼리를 N번 사용한다. (반복해서 읽기 때문에 비효율적)
- 구하는 값을 문자열로 모두 결합하고, subString 한다. (Type사용 하기도 함)
    
    ![image](https://github.com/user-attachments/assets/d64adac9-8d96-43f2-8278-6c85ae4e47b6)

    
- 뷰가 머징되어 Group By 처리가 안되면 Pushdown을 활용하자.

### 5. 스칼라 서브쿼리 Unnesting

스칼라 서브쿼리도 NL 방식으로 조인하기 때문에 캐싱 효과가 없다면 랜덤 I/O 부하가 있다.

특히 병렬 쿼리에선 스칼라 서브쿼리 사용을 지양하자.

오라클 12c 부터 스칼라 서브쿼리도 Unnesting이 가능해졌다. (실행계획 자유도 증가)
