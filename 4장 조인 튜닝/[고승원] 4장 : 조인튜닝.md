# 4장 조인 튜닝

# 4.1 NL 조인

NL 조인은 인덱스를 이용한 조인이다.

## 4.1.1 기본 메커니즘

![image](https://github.com/user-attachments/assets/9970340a-3a80-4b8f-ad3c-478661eba90d)

1. 드라이빙 테이블에서 레코드를 찾는다.
2. 1번 데이터를 드리븐 테이블에서 찾는다.
3. 건바이건으로 1~2 반복

드라이빙, 드리븐 테이블의 인덱스를 모두 이용한다. (사이즈가 작으면 Full Table Scan 해버림)

## 4.1.2 NL 조인 실행계획 제어

```jsx
0		SELECT STATEMENT Optimizer=ALL_ROWS
1	0		NESTED LOOPS
2	1			TABLE ACCESS (BY INDEX ROWID) OF '사원' (TABLE)
3	2				INDEX (RANGE SCAN) OF '사원X1' (INDEX)
4	1			TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE)
5	4				INDEX (RANGE SCAN) OF '고객_X1' (INDEX)
```

힌트

- use_nl (테이블) : 괄호 안의 테이블이 드리븐 테이블일 떄 NL조인을 사용한다.
- ordered : FROM절에 기술한 순서대로 조인하도록 지시
- use_hash (테이블) : 괄호 안의 테이블이 드리븐 테이블일 떄 해시조인을 사용한다.

## 4.1.3 NL조인 수행 과정 분석

![image](https://github.com/user-attachments/assets/7d1931a0-1d1d-4443-8135-6b73c3069f43)

비교 순서 : 2 - 3 - 1 - 4

실행 계획

![image](https://github.com/user-attachments/assets/8fbb9b46-d7bb-4ce3-815e-371f95d97de9)

1. (2) 입사일자를 사원_X1 인덱스를 Range Scan한다.
2. (3) 1에서 얻은 ROWID로 테이블에 액세스해서 부서코드 필터링을 한다.
3. (1) 2에서 얻은 사원번호 값으로 고객쪽 레코드를 고객_X1 인덱스로 Range Scan 한다.
4. (4) 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블을 액세스해서 최종주문금액을 필터링한다.

![image](https://github.com/user-attachments/assets/e7ac3be3-c42a-4d86-bd99-cb47334a996f)

## 4.1.4 NL 조인 튜닝 포인트

튜닝 포인트

- 사원_X1 인덱스 이후 테이블에 액세스 할 때 (13, 21, 3, 25, 23) → 랜덤 액세스임
- 고객_X1 인덱스 탐색 부분 (5, 7, 9, 11, 27 ..) → 수평 스캔 과정에서 블록 I/O 많을 수 있음
- 고객_X1 인덱스 이후 테이블에 액세스 할 때 (6, 8, 28, 10 …) → 랜덤 액세스임

**올바른 조인 메소드 선택**

- OLTP는 NL조인부터 고려하라.
- 성능이 느리다면 랜덤 액세스, 조인 순서 순으로 튜닝 포인트를 잡아라.
- NL 조인으로 안된다 판단되면 소트머지 조인 또는 해시조인을 검토하라.

## 4.1.5 NL 조인 특징 요약

- 랜덤 액세스 위주의 조인 방식 (대용량 데이터에서 비효율 존재)
- 한 레코드씩 순차적 진행 (느려도 빠른 응답 가능)
- 인덱스 구성 전략이 매우 중요하다.
- OLTP 시스템에 적합하다.

## 4.1.6 NL 조인 튜닝 실습

쿼리

![image](https://github.com/user-attachments/assets/fec287da-b375-4950-a656-d4df18515821)

### 1번 케이스 (랜덤 액세스)

트레이스

![image](https://github.com/user-attachments/assets/6a0be8c6-9846-482b-9e1a-99ea4273f6d1)

테이블 액세스 횟수가 2780인데, 필터링 결과는 세 건에 그친다.

이런 경우 인덱스에 테이블 필터 조건 컬럼을 추가하는 것을 고려하라.

### 2번 케이스 (일량 확인)

트레이스

![image](https://github.com/user-attachments/assets/51a4659c-47a4-4819-adb8-f2a4f069833c)

테이블 액세스가 현저히 줄어들었지만, 인덱스 스캔 단계에서 일량이 확인되지 않는다.

`e.입사일자 >= '19960101'` 에 해당하는 레코드가 아주 많다면 `e.부서코드 = 'Z123'` 조건을 필터링 했을거지만, 어떻게 될지는 스캔 후 출력 건수를 따로 확인해야 한다.

![image](https://github.com/user-attachments/assets/b0456118-2cb6-4bf8-84eb-8668f4d0ca3b)

* cr : 논리적인 블록 요청 횟수 / pr : 디스크에서 읽은 블록 수 / pw : 디스크에 쓴 블록 수

사원_X1 인덱스로부터 읽은 블록이 100개가 넘는다. → 3개를 얻기 위해 50,000개 탐색

방법은 인덱스에 컬럼 순서를 (부서코드, 입사일자)로 조정한다.

### 3번 케이스 (조인 순서)

트레이스

![image](https://github.com/user-attachments/assets/900286c2-50d0-42bb-ac89-6af2e54bcdf9)

고객 테이블과 조인하는 횟수가 너무 많다. 최종주문금액 조건절에 부합하는 레코드가 별로 없다면 순서를 변경해보자.

순서를 변경해도 큰 변화가 없다면 소트/해시 조인을 고려해보자.

## 4.1.7 NL 조인 확장 메커니즘

NL조인 성능을 위해 Prefetch, 배치 I/O 기능이 있다.

* Prefetch : 인덱스를 이용해 테이블 액세스를 하다가 디스크 I/O가 필요해지면 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재

![image](https://github.com/user-attachments/assets/e3e33d92-9c8d-4183-a091-ce2a67ae97a3)

* 배치 I/O : 디스크 I/O를 미뤘다가 일정량이 쌓이면 한 번에 처리

![image](https://github.com/user-attachments/assets/e416a0fe-ae93-4385-abb2-ec5466ea0814)

오라클 11g에선 위의 실행계획이 모두 나타나는데, Inner 테이블 블록을 모두 버퍼캐시에서 읽으면 성능은 동일하다.

디스크에서 읽게 되는 순간 성능차이가 발생하고, 배치 I/O는 정렬 순서를 보장하지 않는다.

따라서 인라인 뷰에서 정렬 후 한 건씩 NL 조인 하도록 해서 정렬 순서를 보장하기도 한다.

# 4.2 소트 머지 조인

소트 머지 조인은 대량의 데이터를 다룰 때 해시 조인을 사용할 수 없으면 선택한다.

## 4.2.1 SGA vs PGA

![image](https://github.com/user-attachments/assets/ef4869ee-c305-4651-bb43-d97df583f6eb)

SGA : 공유 메모리 영역

- 동시에 한 프로세스만 접근 가능
- 락과 래치 사용
- DB 버퍼 캐시가 핵심 요소

PGA : 각 오라클 서버에 할당된 메모리 영역

- 독립적인 공간이므로 래치 불필요
- SGA 버퍼캐시보다 훨씬 빠르다.

## 4.2.2 기본 메커니즘

소트 머지 조인 순서

1. 소트 단계 : 양쪽 집합을 조인 컬럼을 기준으로 정렬
2. 머지 단계 : 정렬한 양쪽 집합을 서로 머지 한다.

### 과정

![image](https://github.com/user-attachments/assets/1a3d6508-0a52-4824-ae9f-3b082c470bd0)

use_merge() 힌트를 통해 소트 머지 조인을 유도한다.

1. 소트
- 사원 테이블 데이터를 읽어 사원번호 순으로 정렬한다.
- 정렬된 결과는 PGA의 Sort Area에 저장된다. (너무 크면 Temp 스페이스)

![image](https://github.com/user-attachments/assets/9b56b0d8-d007-4046-a50a-b6d695e79e9e)

1. 소트2
- 고객 테이블 데이터를 읽어 관리사원번호 순으로 정렬한다.
- 정렬된 결과는 PGA의 Sort Area에 저장된다. (너무 크면 Temp 스페이스)

1. 저장한 사원 데이터를 스캔하면서 PGA에 저장한 고객 데이터와 조인한다.

![image](https://github.com/user-attachments/assets/0b6feaa1-d613-44ea-9658-4d2fc61cadd3)

주목할 점은, 사원 데이터를 기준으로 고객 데이터는 매번 Range Scan한다. (인덱스가 없어도 가능)

## 4.2.3 소트 머지 조인이 빠른 이유

NL 조인과 비교해서 소트 머지 조인이 빠른 이유

- NL조인은 인덱스를 이용해서 **건건이** DB 버퍼캐시 경우 (래치 있음)
- 소트 머지 조인은 일괄로 읽고 PGA에 저장 후 처리 (래치 없음)
- 따라서 대량 데이터 조인에 더 빠름

## 4.2.4 소트 머지 조인의 주용도

대부분 해시 조인이 더 빨라서 잘 쓰이지 않음

소트 머지 조인이 더 빠를 때

- 해시 조인을 못쓸 때 (조인 조건이 = 이 아닐 때)
- 조인 조건식이 없는 조인 (Cross Join)

## 4.2.5 소트 머지 조인 제어하기

![image](https://github.com/user-attachments/assets/287a2ddf-722a-41c6-8e4a-acb159d34412)

인덱스를 이용해 소트 대상을 찾고, 소트 후 머지한다.

힌트는 use_merge(테이블)

## 4.2.6 소트 머지 특징 요약

- 실시간으로 인덱스를 생성하는 것과 다름 없음
- 정렬 이후 NL 조인 사용
- PGA 영역을 사용해서 빠르다.
- 조인 컬럼 인덱스의 영향을 받지 않는다.

# 4.3 해시 조인

## 4.3.1 기본 메커니즘

1. Build 단계 : 작은 쪽 테이블을 읽어 해시 테이블을 생성한다.
2. Probe 단계 : 큰 쪽 테이블을 읽어 해시 테이블을 탐색하며 조인한다.

### 과정

1. Build
- 해시 함수를 통해 해시 맵을 생성한다.
- 키 값은 조인컬럼이 된다.
- 반환된 해시 테이블은 PGA 영역의 Hash Area에 저장된다. (너무 크면 Temp)

1. Probe
- 작은쪽 해시 테이블음 탐색해 해시 체인을 찾는다.
- 조인될 테이블을 해시함수에 입력해 해시 체인을 찾고, 해시 체인을 스캔해서 조인조건을 만족시킨다.

![image](https://github.com/user-attachments/assets/ea4147ec-c4d6-4c92-a49e-73174431cc85)

해시 테이블을 사용하는 것을 제외하면 해시 테이블과 같다.

## 4.3.2 해시 조인이 빠른 이유

- PGA 영역 사용 (래치 사용 안함)
- 양쪽 집합 모두 정렬이 아닌, 작은 한 집합만 해시 맵을 만든다. (PGA 공간 절약)

## 4.3.3 대용량 Build Input 처리

양 테이블 모두 대용량 테이블인 경우 **분할 정복**을 한다.

1. 파티션 단계 : 양쪽 집합의 조인 컬럼에 해시 함수를 적용하고 결과에 따라 파티셔닝을 한다.

![image](https://github.com/user-attachments/assets/0ddb49bb-8e20-4563-9980-f822038bcdc8)

1. 조인 단계 : 파티션 짝 별로 조인을 수행한다.

## 4.3.4 해시 조인 실행계획 제어

실행 계획

![image](https://github.com/user-attachments/assets/520f5464-c401-41e1-8121-9eb744007f44)

힌트는 use_hash(테이블)

일반적으로 옵티마이저는 카디널리티가 작은 테이블을 Build Input으로 선택한다.

### 세 개 이상 테이블 해시 조인

조인하는 경로는 결국 한 가지다. 단 leading하는 테이블의 순서는 달라진다.

순서 제어를 위해 leading(A, B, C)를 사용한다.

- A는 무조건 Build Input이 된다.
- A,B의 결과물 또는 C가 Build Input이 된다.
- Build Input 제어는 swap_join_inputs / no_swap_join_inputs로 한다.
- 세 개가 아닌 그 이상의 조인에도 똑같은 원리를 적용한다.

## 4.3.5 조인 메서드 선택 기준

![image](https://github.com/user-attachments/assets/9aee3170-781c-457f-9a03-4ed1d1d9d066)

* 대량의 기준은 랜덤 액세스가 많은 경우, 성능이 안나오는 경우

수행 빈도가 매우 높은 쿼리의 경우

1. NL 조인과 해시 조인 성능이 같으면 → NL 선택
2. 해시가 좀 더 빨라도 → NL 선택
3. NL 조인보다 해시 조인이 매우 빠르면 → 해시 선택

NL조인을 가장 먼저 고려하는 이유

- NL 조인에 사용되는 인덱스는 영구적으로 유지된다.
- 반면에 해시 조인에 사용되는 해시 테이블은 일회성으로 사용되고, 소멸된다. (CPU, 메모리)
- 해시 테이블을 만들 때 래치 경합이 발생한다.

보통 수행 빈도가 낮고, 수행 시간이 오래걸리고, 대량일 때 해시 조인을 사용한다. (배치)
