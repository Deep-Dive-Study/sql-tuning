# 4장 조인 튜닝

# 4.1 NL 조인

NL 조인은 인덱스를 이용한 조인이다.

## 4.1.1 기본 메커니즘

![image](https://github.com/user-attachments/assets/9970340a-3a80-4b8f-ad3c-478661eba90d)

1. 드라이빙 테이블에서 레코드를 찾는다.
2. 1번 데이터를 드리븐 테이블에서 찾는다.
3. 건바이건으로 1~2 반복

드라이빙, 드리븐 테이블의 인덱스를 모두 이용한다. (사이즈가 작으면 Full Table Scan 해버림)

## 4.1.2 NL 조인 실행계획 제어

```jsx
0		SELECT STATEMENT Optimizer=ALL_ROWS
1	0		NESTED LOOPS
2	1			TABLE ACCESS (BY INDEX ROWID) OF '사원' (TABLE)
3	2				INDEX (RANGE SCAN) OF '사원X1' (INDEX)
4	1			TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE)
5	4				INDEX (RANGE SCAN) OF '고객_X1' (INDEX)
```

힌트

- use_nl (테이블) : 괄호 안의 테이블이 드리븐 테이블일 떄 NL조인을 사용한다.
- ordered : FROM절에 기술한 순서대로 조인하도록 지시
- use_hash (테이블) : 괄호 안의 테이블이 드리븐 테이블일 떄 해시조인을 사용한다.

## 4.1.3 NL조인 수행 과정 분석

![image](https://github.com/user-attachments/assets/7d1931a0-1d1d-4443-8135-6b73c3069f43)

비교 순서 : 2 - 3 - 1 - 4

실행 계획

![image](https://github.com/user-attachments/assets/8fbb9b46-d7bb-4ce3-815e-371f95d97de9)

1. (2) 입사일자를 사원_X1 인덱스를 Range Scan한다.
2. (3) 1에서 얻은 ROWID로 테이블에 액세스해서 부서코드 필터링을 한다.
3. (1) 2에서 얻은 사원번호 값으로 고객쪽 레코드를 고객_X1 인덱스로 Range Scan 한다.
4. (4) 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블을 액세스해서 최종주문금액을 필터링한다.

![image](https://github.com/user-attachments/assets/e7ac3be3-c42a-4d86-bd99-cb47334a996f)

## 4.1.4 NL 조인 튜닝 포인트

튜닝 포인트

- 사원_X1 인덱스 이후 테이블에 액세스 할 때 (13, 21, 3, 25, 23) → 랜덤 액세스임
- 고객_X1 인덱스 탐색 부분 (5, 7, 9, 11, 27 ..) → 수평 스캔 과정에서 블록 I/O 많을 수 있음
- 고객_X1 인덱스 이후 테이블에 액세스 할 때 (6, 8, 28, 10 …) → 랜덤 액세스임

**올바른 조인 메소드 선택**

- OLTP는 NL조인부터 고려하라.
- 성능이 느리다면 랜덤 액세스, 조인 순서 순으로 튜닝 포인트를 잡아라.
- NL 조인으로 안된다 판단되면 소트머지 조인 또는 해시조인을 검토하라.

## 4.1.5 NL 조인 특징 요약

- 랜덤 액세스 위주의 조인 방식 (대용량 데이터에서 비효율 존재)
- 한 레코드씩 순차적 진행 (느려도 빠른 응답 가능)
- 인덱스 구성 전략이 매우 중요하다.
- OLTP 시스템에 적합하다.

## 4.1.6 NL 조인 튜닝 실습

쿼리

![image](https://github.com/user-attachments/assets/fec287da-b375-4950-a656-d4df18515821)

### 1번 케이스 (랜덤 액세스)

트레이스

![image](https://github.com/user-attachments/assets/6a0be8c6-9846-482b-9e1a-99ea4273f6d1)

테이블 액세스 횟수가 2780인데, 필터링 결과는 세 건에 그친다.

이런 경우 인덱스에 테이블 필터 조건 컬럼을 추가하는 것을 고려하라.

### 2번 케이스 (일량 확인)

트레이스

![image](https://github.com/user-attachments/assets/51a4659c-47a4-4819-adb8-f2a4f069833c)

테이블 액세스가 현저히 줄어들었지만, 인덱스 스캔 단계에서 일량이 확인되지 않는다.

`e.입사일자 >= '19960101'` 에 해당하는 레코드가 아주 많다면 `e.부서코드 = 'Z123'` 조건을 필터링 했을거지만, 어떻게 될지는 스캔 후 출력 건수를 따로 확인해야 한다.

![image](https://github.com/user-attachments/assets/b0456118-2cb6-4bf8-84eb-8668f4d0ca3b)

* cr : 논리적인 블록 요청 횟수 / pr : 디스크에서 읽은 블록 수 / pw : 디스크에 쓴 블록 수

사원_X1 인덱스로부터 읽은 블록이 100개가 넘는다. → 3개를 얻기 위해 50,000개 탐색

방법은 인덱스에 컬럼 순서를 (부서코드, 입사일자)로 조정한다.

### 3번 케이스 (조인 순서)

트레이스

![image](https://github.com/user-attachments/assets/900286c2-50d0-42bb-ac89-6af2e54bcdf9)

고객 테이블과 조인하는 횟수가 너무 많다. 최종주문금액 조건절에 부합하는 레코드가 별로 없다면 순서를 변경해보자.

순서를 변경해도 큰 변화가 없다면 소트/해시 조인을 고려해보자.

## 4.1.7 NL 조인 확장 메커니즘

NL조인 성능을 위해 Prefetch, 배치 I/O 기능이 있다.

* Prefetch : 인덱스를 이용해 테이블 액세스를 하다가 디스크 I/O가 필요해지면 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재

![image](https://github.com/user-attachments/assets/e3e33d92-9c8d-4183-a091-ce2a67ae97a3)

* 배치 I/O : 디스크 I/O를 미뤘다가 일정량이 쌓이면 한 번에 처리

![image](https://github.com/user-attachments/assets/e416a0fe-ae93-4385-abb2-ec5466ea0814)

오라클 11g에선 위의 실행계획이 모두 나타나는데, Inner 테이블 블록을 모두 버퍼캐시에서 읽으면 성능은 동일하다.

디스크에서 읽게 되는 순간 성능차이가 발생하고, 배치 I/O는 정렬 순서를 보장하지 않는다.

따라서 인라인 뷰에서 정렬 후 한 건씩 NL 조인 하도록 해서 정렬 순서를 보장하기도 한다.
