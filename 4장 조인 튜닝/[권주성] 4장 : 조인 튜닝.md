# 4장 조인 튜닝
## 4.1 NL 조인
- **`NL(Nested Loop) 조인`**
  - 기본 조인 방식
  - 인덱스를 이용하는 조인 방식

- **`소트 머지 조인`** 과 **`해시 조인`** 과도 프로세싱 과정은 전부 유사함(조인할 때 어떤 자료구조를 사용하느냐의 차이일 뿐)

### 4.1.1 기본 메커니즘
- 건건이 드라이빙 테이블의 로우마다 드라이븐 테이블에서 일치하는 데이터를 찾음
  - 중첩 반복문 매커니즘과 동일

    ![Google Chrome 2024-08-22 19 30 57](https://github.com/user-attachments/assets/c42c04ff-c3ba-44e6-8c66-73089e2e3201)

    ![Google Chrome 2024-08-22 19 30 46](https://github.com/user-attachments/assets/512feb52-95f2-4d48-aed9-27c6dc8d287f)

- 따라서, **`드라이빙(Outer) 테이블이 적어야 전체 조인 횟수가 줄어듬`**
- 일반적으로, NL조인은 Outer,Inner 양쪽 테이블 모두 인덱스를 이용함
  - **`드라이븐(Inner) 테이블에서 인덱스를 활용할 수 없으면 성능에 큰 부하가 있음`**
  - **드라이빙(Outer)의 경우, 1번의 풀테이블 스캔으로 가져오면 계속 이용할 수 있지만 드라이븐은 드라이빙에서 가져온 로우마다 한번씩 찾기때문에 인덱스를 활용이 필수적임**

- 소트 머지와 해시 조인도 이러한 중첩 루프를 돌면서 찾는 프로세싱 과정은 동일함
  - 각각 Sort Area와 Hash Area에 가공해둔 데이터를 넣어두고 이용한다는 점에서만 차이가 존재함 

### 4.1.2 NL 조인 실행계획 제어
- 예시

  ![CleanShot 2024-08-22 at 19 39 50@2x](https://github.com/user-attachments/assets/2e3fb5b1-d3e8-4d96-b7f1-3a0db4e8f720)

  - 해석 : 위쪽 사원 테이블 기준으로 아래쪽 고객 테이블과 NL 조인한다 (사원 테이블 기준에서 → 고객 테이블 순서로)
 
- NL 조인을 제어할때는 **`use_nl`** 힌트를 사용함(Oracle)
  - **`ordered`** 힌트는 FROM 절에 기술한 순서대로 조인하라고 옵티마이저에 지시할때 사용함
  - ordered 대신 **`leading`** 힌트를 사용하면 지정한 순서대로 조인 순서를 제어 가능
  - 힌트를 기술하지 않을때는 옵티마이저가 스스로 정함

    ![CleanShot 2024-08-22 at 19 41 40@2x](https://github.com/user-attachments/assets/f7a1a0da-4c26-4944-8b18-59afb8d37029)

### 4.1.3 NL 조인 수행과정 분석

## 4.2 소트 머지 조인
- 조인 컬럼에 인덱스가 없을 때, 혹은 대량 데이터 조인이어서 인덱스가 효과적이지 않을 때, 옵티마이저는 NL조인 대신 소트 머지 조인(해시 조인)을 사용함
- 해시 조인이 등장한 이후, 대부분의 경우 해시 조인이 유용하나 해시 조인을 사용할 수 없는 상황에서 대량 데이터를 조인하고자 할 때 여전히 유용함

### 4.2.1 SGA vs PGA
![CleanShot 2024-08-22 at 19 51 46@2x](https://github.com/user-attachments/assets/3b0caaee-1cc0-4ee3-8167-fdf37a4393e9)

  - SGA(Shared/System Global Area : 시스템/공유 글로벌 메모리 영역)
    - 여러 프로세스가 공유 가능
    - 동시에 액세스는 안됨. 이를 직렬화하기 위해 Lock 매커니즘으로서 래치(Latch)가 존재함
    - DB 버퍼캐시는 SGA의 가장 핵심 구성요소이며, 여기서 블록을 읽기 위해서는 버퍼 Lock을 획득해야함
  - PGA(Private/Program Global Area : 각 프로세스의 개별 메모리 영역)
    - 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용함
    - 해당 영역이 작아 데이터를 전부 저장할 수 없는 경우에는 Temp 테이블 스페이스를 이용함
    - **`독립적인 메모리 공간이므로 래치 메커니즘이 불필요함`**
      - 따라서, 매우 빠르게 액세스 가능

### 4.2.2 기본 매커니즘
- 소트 머지 조인은 소트 단계와 머지 단계로 구분됨
  - 소트 단계 : 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
  - 머지 단계 : 정렬한 양쪽 집합을 서로 머지한다.

1. 조인 컬럼 기준으로 드라이빙(Outer) 테이블을 정렬한 후 정렬한 결과 집합은 PGA영역인 Sort Area에 저장한다(안되면 Temp 테이블 스페이스)
2. 동일한 방식으로 조인 컬럼 기준으로 드라이븐(Inner) 테이블을 정렬하고 저장한다
3. PGA에 저장한 드라이빙 테이블을 스캔하면서 드라이븐 테이블의 데이터와 조인한다.
  - NL 조인과 동일. 매번 드라이븐 테이블을 Full Scan 하지 않아도 됨
  - 또한, 정렬되어 있기때문에 Range를 정하기 쉬움

    ![CleanShot 2024-08-22 at 20 10 42@2x](https://github.com/user-attachments/assets/5d7a73d7-1157-4a4a-9def-831e252a3af9)

### 4.2.3 소트 머지 조인이 빠른 이유
- NL 조인은 대량 데이터를 조인할때 성능이 매우 느리다는 치명적 단점이 있음
- NL 조인이 느린 이유는 인덱스를 이용하기 때문에 건건이 DB 버퍼 캐시를 경유해서 읽기 때문
  - 래치 획득 및 캐시 버퍼 체인 스캔 과정을 거치는 것이 느림
  - 인덱스 손익 분기점의 한계점

### 4.2.4 소트 머지 조인의 주용도
- 해시 조인이 소트 머지 조인보다 빠르나 등치 조건이 아닐 때 사용할 수 없다는 단점이 있음
- 따라서, 아래의 경우에는 소트 머지 조인이 유요함
  - 조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인
  - 조인 조건식이 아예 없는 조인(Cross Join, 카테시안 곱)

### 4.2.5 소트 머지 조인 제어하기
- 예시

  ![CleanShot 2024-08-22 at 20 40 41@2x](https://github.com/user-attachments/assets/eb03f75e-8cbe-40d6-8fd7-c7e8d49e71c7)

  - 해석: 양쪽 테이블을 각각 소트한 후, 위쪽 사원 테이블 기준으로 아래쪽 고객 테이블과 머지 조인한다
    - 소트할 대상을 찾기 위해 각 테이블을 액세스할 때 인덱스를 이용한다는 점을 확인 가능   

- 소트 머지 조인 실행 계획을 제어할 때 **`use_merge`** 힌트를 사용 

  ![CleanShot 2024-08-22 at 20 40 49@2x](https://github.com/user-attachments/assets/c7be8b52-6a21-481b-ae24-caad0877fe19)

### 4.2.6 소트 머지 조인 특징 요약
- 소트 머지 조인은 조인을 위해 실시간으로 인덱스를 생성하는 것과 다름 없음
- 소트 부하만 감수한다면, 건건이 버퍼 캐시를 경유하는 NL 조인보다 빠름
- NL 조인은 조인 컬럼에 대한 인덱스 유무에 크게 영향을 받지만, 소트 머지 조인은 영향을 받지 않음
- 양쪽 집합을 개별적으로 읽은 후 조인을 시작하는 방식
- 조인 컬럼에 인덱스가 없는 상황에서 두 테이블을 각각 읽어 조인 대상 집합을 줄일 수 있을때 아주 유리함
- 스캔 위주의 액세스 방식을 사용함
- 양쪽 소스 집합으로부터 조인 대상 레코드를 찾는데 인덱스를 이용할 수 있고, 그때는 랜덤 액세스가 일어남(해시 조인도 동일)

