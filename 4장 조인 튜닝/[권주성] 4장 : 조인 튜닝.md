# 4장 조인 튜닝
## 4.1 NL 조인
- **`NL(Nested Loop) 조인`**
  - 기본 조인 방식
  - 인덱스를 이용하는 조인 방식

- **`소트 머지 조인`** 과 **`해시 조인`** 과도 프로세싱 과정은 전부 유사함(조인할 때 어떤 자료구조를 사용하느냐의 차이일 뿐)

### 4.1.1 기본 메커니즘
- **건건이 드라이빙 테이블의 로우마다 드라이븐 테이블에서 일치하는 데이터를 찾음**
  - **`중첩 반복문 매커니즘`** 과 동일

    ![Google Chrome 2024-08-22 19 30 57](https://github.com/user-attachments/assets/c42c04ff-c3ba-44e6-8c66-73089e2e3201)

    ![Google Chrome 2024-08-22 19 30 46](https://github.com/user-attachments/assets/512feb52-95f2-4d48-aed9-27c6dc8d287f)

- 따라서, **`드라이빙(Outer) 테이블이 적어야 전체 조인 횟수가 줄어듬`**
- 일반적으로, NL조인은 Outer,Inner 양쪽 테이블 모두 인덱스를 이용함
  - **`드라이븐(Inner) 테이블에서 인덱스를 활용할 수 없으면 성능에 큰 부하가 있음`**
  - **드라이빙(Outer)의 경우, 1번의 풀테이블 스캔으로 가져오면 계속 이용할 수 있지만 드라이븐은 드라이빙에서 가져온 로우마다 한번씩 찾기때문에 인덱스를 활용이 필수적임**

- 소트 머지와 해시 조인도 이러한 중첩 루프를 돌면서 찾는 프로세싱 과정은 동일함
  - 각각 Sort Area와 Hash Area에 가공해둔 데이터를 넣어두고 이용한다는 점에서만 차이가 존재함 


- 예시
  - 쿼리

    ![CleanShot 2024-08-24 at 02 35 49](https://github.com/user-attachments/assets/ea980384-1b54-4378-9c1f-dc4d31acf66f)

  - 사원과 고객 테이블 조인 과정  
  
    ![CleanShot 2024-08-24 at 02 33 50](https://github.com/user-attachments/assets/383cff79-daaa-4e0f-95c5-65622ecc9357)

    ![CleanShot 2024-08-24 at 02 34 12](https://github.com/user-attachments/assets/3b6c1fec-27cc-4a57-bdf0-2888d1b06391)

    ![CleanShot 2024-08-24 at 02 34 30](https://github.com/user-attachments/assets/3a002d87-aa01-4d72-a544-e25e705d7c96)

    ![CleanShot 2024-08-24 at 02 34 51](https://github.com/user-attachments/assets/a5862c2c-0c0e-48eb-92bf-40f41ef1ea6e)

    ![CleanShot 2024-08-24 at 02 38 11](https://github.com/user-attachments/assets/22f83e53-41a8-418b-8ce8-b86151fba786)

### 4.1.2 NL 조인 실행계획 제어
- 예시

  ![CleanShot 2024-08-22 at 19 39 50@2x](https://github.com/user-attachments/assets/2e3fb5b1-d3e8-4d96-b7f1-3a0db4e8f720)

  - 해석 : 위쪽 사원 테이블 기준으로 아래쪽 고객 테이블과 NL 조인한다 (사원 테이블 기준에서 → 고객 테이블 순서로)
 
- NL 조인을 제어할때는 **`use_nl`** 힌트를 사용함(Oracle)
  - **`ordered`** 힌트는 FROM 절에 기술한 순서대로 조인하라고 옵티마이저에 지시할때 사용함
  - ordered 대신 **`leading`** 힌트를 사용하면 지정한 순서대로 조인 순서를 제어 가능
  - 힌트를 기술하지 않을때는 옵티마이저가 스스로 정함

    ![CleanShot 2024-08-22 at 19 41 40@2x](https://github.com/user-attachments/assets/f7a1a0da-4c26-4944-8b18-59afb8d37029)

    ![CleanShot 2024-08-24 at 02 55 36](https://github.com/user-attachments/assets/004d3952-11cd-40e3-ac88-cc0347fbff79)


### 4.1.3 NL 조인 수행과정 분석
![CleanShot 2024-08-24 at 02 41 29](https://github.com/user-attachments/assets/b956b97f-7422-46fa-b019-bc9dabc75fa7)

![CleanShot 2024-08-24 at 02 56 29](https://github.com/user-attachments/assets/86bb706c-4473-4508-9ffa-f048dc734fec)

![CleanShot 2024-08-24 at 02 41 52](https://github.com/user-attachments/assets/a401ff3d-fcc3-4d99-a39c-1df5b83b7f29)

- **전체 과정**

  ![CleanShot 2024-08-24 at 02 38 54](https://github.com/user-attachments/assets/ea028ede-a99f-4d48-8a93-8fccad46acaa)

  - **`각 단계를 모두 완료하고 다음 단계로 넘어가는 게 아니라 한 레코드씩 순차적으로 진행`**

### 4.1.4 NL 조인 튜닝 포인트
- 위의 조인 과정에서 어떤 튜닝 포인트가 있을까?
  - `사원_X1 인덱스를 읽고 나서 사원 테이블을 액세스 하는 부분`
    - 부서 코드에 필터링이 많이 된다면, 인덱스에 부서 코드 컬럼 추가 검토  
  - `고객_X1 인덱스를 탐색하는 부분`(조인 액세스 줄이기)
  - `고객_X1 인덱스를 읽고 나서 고객 테이블을 액세스하는 부분`
    - 최종 주문 금액으로 필터링이 많이 된다면, 인덱스에 최소 주문 금액 컬럼 추가 검토   

#### 올바른 조인 메서드 선택
- **`OLTP 시스템에서는 일차적으로 NL 조인을 고려하는 것이 올바른 순서`**
- 만약 성능이 느린 경우, NL 조인 튜닝 포인트에 따라 각 단계의 수행 일량을 분석해서 과도한 랜덤 액세스가 발생하는 지점을 우선 파악
  - **조인 순서 변경, 다른 인덱스 검토(추가 혹은 구성 변경),등을 고려**
- 여러 방안을 검토했음에도 성능이 느린 경우에만 소트 머지 조인과 해시 조인을 고려하는 것이 좋음

### 4.1.5 NL 조인 특징 요약
- **`랜덤 액세스 위주의 조인 방식`**
- **`한 레코드씩 순차적으로 진행`**
- **`인덱스 구성 전략이 특히 중요함`** (영향)
- **`OLTP 시스템에 적합한 조인 방식`**
  - 소량 데이터 혹은 부분범위 처리가 가능한 경우

### 4.1.6 NL 조인 튜닝 실습
- 책 보고 한번 따라해보거나, 회사에서 실전으로 적용해보면 좋을 것 같음

### 4.1.7 NL 조인 확장 메커니즘

## 4.2 소트 머지 조인
- **`조인 컬럼에 인덱스가 없을 때, 혹은 대량 데이터 조인이어서 인덱스가 효과적이지 않을 때, 옵티마이저는 NL조인 대신 소트 머지 조인(해시 조인)을 사용함`**
- **해시 조인이 등장한 이후, 대부분의 경우 해시 조인이 유용하나 해시 조인을 사용할 수 없는 상황에서 대량 데이터를 조인하고자 할 때 여전히 유용함**

### 4.2.1 SGA vs PGA
![CleanShot 2024-08-22 at 19 51 46@2x](https://github.com/user-attachments/assets/3b0caaee-1cc0-4ee3-8167-fdf37a4393e9)

  - `SGA`(Shared/System Global Area : 시스템/공유 글로벌 메모리 영역)
    - 여러 프로세스가 공유 가능
    - 동시에 액세스는 안됨. 이를 직렬화하기 위해 Lock 매커니즘으로서 래치(Latch)가 존재함
    - DB 버퍼캐시는 SGA의 가장 핵심 구성요소이며, 여기서 블록을 읽기 위해서는 버퍼 Lock을 획득해야함
  - **`PGA`** (Private/Program Global Area : 각 프로세스의 개별 메모리 영역)
    - 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용함
    - 해당 영역이 작아 데이터를 전부 저장할 수 없는 경우에는 Temp 테이블 스페이스를 이용함
    - **`독립적인 메모리 공간이므로 래치 메커니즘이 불필요함`**
      - 따라서, 매우 빠르게 액세스 가능

### 4.2.2 기본 매커니즘
- 소트 머지 조인은 소트 단계와 머지 단계로 구분됨
  - **`소트 단계`** : 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
  - **`머지 단계`** : 정렬한 양쪽 집합을 서로 머지한다.

1. 조인 컬럼 기준으로 드라이빙(Outer) 테이블을 정렬한 후 정렬한 결과 집합은 PGA영역인 Sort Area에 저장한다(안되면 Temp 테이블 스페이스)
2. 동일한 방식으로 조인 컬럼 기준으로 드라이븐(Inner) 테이블을 정렬하고 저장한다
3. PGA에 저장한 드라이빙 테이블을 스캔하면서 드라이븐 테이블의 데이터와 조인한다.
    - NL 조인과 동일. 매번 드라이븐 테이블을 Full Scan 하지 않아도 됨
    - 또한, 정렬되어 있기때문에 Range를 정하기 쉬움

    ![CleanShot 2024-08-22 at 20 10 42@2x](https://github.com/user-attachments/assets/5d7a73d7-1157-4a4a-9def-831e252a3af9)

### 4.2.3 소트 머지 조인이 빠른 이유
- NL 조인은 대량 데이터를 조인할때 성능이 매우 느리다는 치명적 단점이 있음
- **`NL 조인이 느린 이유는 인덱스를 이용하기 때문에 건건이 DB 버퍼 캐시를 경유해서 읽기 때문`**
  - 래치 획득 및 캐시 버퍼 체인 스캔 과정을 거치는 것이 느림
  - 인덱스 손익 분기점의 한계점

### 4.2.4 소트 머지 조인의 주용도
- **`해시 조인이 소트 머지 조인보다 빠르나 등치 조건이 아닐 때 사용할 수 없다는 단점이 있음`**
- 따라서, 아래의 경우에는 소트 머지 조인이 유요함
  - **`조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인`**
  - **`조인 조건식이 아예 없는 조인(Cross Join, 카테시안 곱)`**

### 4.2.5 소트 머지 조인 제어하기
- 예시

  ![CleanShot 2024-08-22 at 20 40 41@2x](https://github.com/user-attachments/assets/eb03f75e-8cbe-40d6-8fd7-c7e8d49e71c7)

  - 해석: 양쪽 테이블을 각각 소트한 후, 위쪽 사원 테이블 기준으로 아래쪽 고객 테이블과 머지 조인한다
    - 소트할 대상을 찾기 위해 각 테이블을 액세스할 때 인덱스를 이용한다는 점을 확인 가능   

- 소트 머지 조인 실행 계획을 제어할 때 **`use_merge`** 힌트를 사용 

  ![CleanShot 2024-08-22 at 20 40 49@2x](https://github.com/user-attachments/assets/c7be8b52-6a21-481b-ae24-caad0877fe19)

### 4.2.6 소트 머지 조인 특징 요약
- **`양쪽 집합을 개별적으로 읽은 후 조인을 시작하는 방식`**
- 소트 머지 조인은 `조인을 위해 실시간으로 인덱스를 생성하는 것과 다름 없음`
- **`소트 부하만 감수한다면, 건건이 버퍼 캐시를 경유하는 NL 조인보다 빠름`**
- NL 조인은 조인 컬럼에 대한 인덱스 유무에 크게 영향을 받지만, **`소트 머지 조인은 (인덱스의) 영향을 받지 않음`**
- 조인 컬럼에 인덱스가 없는 상황에서 두 테이블을 각각 읽어 조인 대상 집합을 줄일 수 있을때 아주 유리함
- `스캔 위주의 액세스 방식을 사용함`
- 양쪽 소스 집합으로부터 조인 대상 레코드를 찾는데 인덱스를 이용할 수 있고, 그때는 랜덤 액세스가 일어남(해시 조인도 동일)

