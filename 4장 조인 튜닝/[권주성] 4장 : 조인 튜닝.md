# 4장 조인 튜닝
## 4.1 NL 조인
- **`NL(Nested Loop) 조인`**
  - 기본 조인 방식
  - 인덱스를 이용하는 조인 방식

- **`소트 머지 조인`** 과 **`해시 조인`** 과도 프로세싱 과정은 전부 유사함(조인할 때 어떤 자료구조를 사용하느냐의 차이일 뿐)

### 4.1.1 기본 메커니즘
- **건건이 드라이빙 테이블의 로우마다 드라이븐 테이블에서 일치하는 데이터를 찾음**
  - **`중첩 반복문 매커니즘`** 과 동일

    ![Google Chrome 2024-08-22 19 30 57](https://github.com/user-attachments/assets/c42c04ff-c3ba-44e6-8c66-73089e2e3201)

    ![Google Chrome 2024-08-22 19 30 46](https://github.com/user-attachments/assets/512feb52-95f2-4d48-aed9-27c6dc8d287f)

- 따라서, **`드라이빙(Outer) 테이블이 적어야 전체 조인 횟수가 줄어듬`**
- 일반적으로, NL조인은 Outer,Inner 양쪽 테이블 모두 인덱스를 이용함
  - **`드라이븐(Inner) 테이블에서 인덱스를 활용할 수 없으면 성능에 큰 부하가 있음`**
  - **드라이빙(Outer)의 경우, 1번의 풀테이블 스캔으로 가져오면 계속 이용할 수 있지만 드라이븐은 드라이빙에서 가져온 로우마다 한번씩 찾기때문에 인덱스를 활용이 필수적임**

- 소트 머지와 해시 조인도 이러한 중첩 루프를 돌면서 찾는 프로세싱 과정은 동일함
  - 각각 Sort Area와 Hash Area에 가공해둔 데이터를 넣어두고 이용한다는 점에서만 차이가 존재함 


- 예시
  - 쿼리

    ![CleanShot 2024-08-24 at 02 35 49](https://github.com/user-attachments/assets/ea980384-1b54-4378-9c1f-dc4d31acf66f)

  - 사원과 고객 테이블 조인 과정  
  
    ![CleanShot 2024-08-24 at 02 33 50](https://github.com/user-attachments/assets/383cff79-daaa-4e0f-95c5-65622ecc9357)

    ![CleanShot 2024-08-24 at 02 34 12](https://github.com/user-attachments/assets/3b6c1fec-27cc-4a57-bdf0-2888d1b06391)

    ![CleanShot 2024-08-24 at 02 34 30](https://github.com/user-attachments/assets/3a002d87-aa01-4d72-a544-e25e705d7c96)

    ![CleanShot 2024-08-24 at 02 34 51](https://github.com/user-attachments/assets/a5862c2c-0c0e-48eb-92bf-40f41ef1ea6e)

    ![CleanShot 2024-08-24 at 02 38 11](https://github.com/user-attachments/assets/22f83e53-41a8-418b-8ce8-b86151fba786)

### 4.1.2 NL 조인 실행계획 제어
- 예시

  ![CleanShot 2024-08-22 at 19 39 50@2x](https://github.com/user-attachments/assets/2e3fb5b1-d3e8-4d96-b7f1-3a0db4e8f720)

  - 해석 : 위쪽 사원 테이블 기준으로 아래쪽 고객 테이블과 NL 조인한다 (사원 테이블 기준에서 → 고객 테이블 순서로)
 
- NL 조인을 제어할때는 **`use_nl`** 힌트를 사용함(Oracle)
  - **`ordered`** 힌트는 FROM 절에 기술한 순서대로 조인하라고 옵티마이저에 지시할때 사용함
  - ordered 대신 **`leading`** 힌트를 사용하면 지정한 순서대로 조인 순서를 제어 가능
  - 힌트를 기술하지 않을때는 옵티마이저가 스스로 정함

    ![CleanShot 2024-08-22 at 19 41 40@2x](https://github.com/user-attachments/assets/f7a1a0da-4c26-4944-8b18-59afb8d37029)

    ![CleanShot 2024-08-24 at 02 55 36](https://github.com/user-attachments/assets/004d3952-11cd-40e3-ac88-cc0347fbff79)


### 4.1.3 NL 조인 수행과정 분석
![CleanShot 2024-08-24 at 02 41 29](https://github.com/user-attachments/assets/b956b97f-7422-46fa-b019-bc9dabc75fa7)

![CleanShot 2024-08-24 at 02 56 29](https://github.com/user-attachments/assets/86bb706c-4473-4508-9ffa-f048dc734fec)

![CleanShot 2024-08-24 at 02 41 52](https://github.com/user-attachments/assets/a401ff3d-fcc3-4d99-a39c-1df5b83b7f29)

- **전체 과정**

  ![CleanShot 2024-08-24 at 02 38 54](https://github.com/user-attachments/assets/ea028ede-a99f-4d48-8a93-8fccad46acaa)

  - **`각 단계를 모두 완료하고 다음 단계로 넘어가는 게 아니라 한 레코드씩 순차적으로 진행`**

### 4.1.4 NL 조인 튜닝 포인트
- 위의 조인 과정에서 어떤 튜닝 포인트가 있을까?
  - `사원_X1 인덱스를 읽고 나서 사원 테이블을 액세스 하는 부분`
    - 부서 코드에 필터링이 많이 된다면, 인덱스에 부서 코드 컬럼 추가 검토  
  - `고객_X1 인덱스를 탐색하는 부분`(조인 액세스 줄이기)
  - `고객_X1 인덱스를 읽고 나서 고객 테이블을 액세스하는 부분`
    - 최종 주문 금액으로 필터링이 많이 된다면, 인덱스에 최소 주문 금액 컬럼 추가 검토   

#### 올바른 조인 메서드 선택
- **`OLTP 시스템에서는 일차적으로 NL 조인을 고려하는 것이 올바른 순서`**
- 만약 성능이 느린 경우, NL 조인 튜닝 포인트에 따라 각 단계의 수행 일량을 분석해서 과도한 랜덤 액세스가 발생하는 지점을 우선 파악
  - **조인 순서 변경, 다른 인덱스 검토(추가 혹은 구성 변경),등을 고려**
- 여러 방안을 검토했음에도 성능이 느린 경우에만 소트 머지 조인과 해시 조인을 고려하는 것이 좋음

### 4.1.5 NL 조인 특징 요약
- **`랜덤 액세스 위주의 조인 방식`**
- **`한 레코드씩 순차적으로 진행`**
- **`인덱스 구성 전략이 특히 중요함`** (영향)
- **`OLTP 시스템에 적합한 조인 방식`**
  - 소량 데이터 혹은 부분범위 처리가 가능한 경우

### 4.1.6 NL 조인 튜닝 실습
- 책 보고 한번 따라해보거나, 회사에서 실전으로 적용해보면 좋을 것 같음

### 4.1.7 NL 조인 확장 메커니즘

## 4.2 소트 머지 조인
- **`조인 컬럼에 인덱스가 없을 때, 혹은 대량 데이터 조인이어서 인덱스가 효과적이지 않을 때, 옵티마이저는 NL조인 대신 소트 머지 조인(해시 조인)을 사용함`**
- **해시 조인이 등장한 이후, 대부분의 경우 해시 조인이 유용하나 해시 조인을 사용할 수 없는 상황에서 대량 데이터를 조인하고자 할 때 여전히 유용함**

### 4.2.1 SGA vs PGA
![CleanShot 2024-08-22 at 19 51 46@2x](https://github.com/user-attachments/assets/3b0caaee-1cc0-4ee3-8167-fdf37a4393e9)

  - `SGA`(Shared/System Global Area : 시스템/공유 글로벌 메모리 영역)
    - 여러 프로세스가 공유 가능
    - 동시에 액세스는 안됨. 이를 직렬화하기 위해 Lock 매커니즘으로서 래치(Latch)가 존재함
    - DB 버퍼캐시는 SGA의 가장 핵심 구성요소이며, 여기서 블록을 읽기 위해서는 버퍼 Lock을 획득해야함
  - **`PGA`** (Private/Program Global Area : 각 프로세스의 개별 메모리 영역)
    - 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용함
    - 해당 영역이 작아 데이터를 전부 저장할 수 없는 경우에는 Temp 테이블 스페이스를 이용함
    - **`독립적인 메모리 공간이므로 래치 메커니즘이 불필요함`**
      - 따라서, 매우 빠르게 액세스 가능

### 4.2.2 기본 매커니즘
- 소트 머지 조인은 소트 단계와 머지 단계로 구분됨
  - **`소트 단계`** : 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
  - **`머지 단계`** : 정렬한 양쪽 집합을 서로 머지한다.

1. 조인 컬럼 기준으로 드라이빙(Outer) 테이블을 정렬한 후 정렬한 결과 집합은 PGA영역인 Sort Area에 저장한다(안되면 Temp 테이블 스페이스)
2. 동일한 방식으로 조인 컬럼 기준으로 드라이븐(Inner) 테이블을 정렬하고 저장한다
3. PGA에 저장한 드라이빙 테이블을 스캔하면서 드라이븐 테이블의 데이터와 조인한다.
    - NL 조인과 동일. 매번 드라이븐 테이블을 Full Scan 하지 않아도 됨
    - 또한, 정렬되어 있기때문에 Range를 정하기 쉬움

    ![CleanShot 2024-08-22 at 20 10 42@2x](https://github.com/user-attachments/assets/5d7a73d7-1157-4a4a-9def-831e252a3af9)

### 4.2.3 소트 머지 조인이 빠른 이유
- NL 조인은 대량 데이터를 조인할때 성능이 매우 느리다는 치명적 단점이 있음
- **`NL 조인이 느린 이유는 인덱스를 이용하기 때문에 건건이 DB 버퍼 캐시를 경유해서 읽기 때문`**
  - 래치 획득 및 캐시 버퍼 체인 스캔 과정을 거치는 것이 느림
  - 인덱스 손익 분기점의 한계점

### 4.2.4 소트 머지 조인의 주용도
- **`해시 조인이 소트 머지 조인보다 빠르나 등치 조건이 아닐 때 사용할 수 없다는 단점이 있음`**
- 따라서, 아래의 경우에는 소트 머지 조인이 유요함
  - **`조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인`**
  - **`조인 조건식이 아예 없는 조인(Cross Join, 카테시안 곱)`**

### 4.2.5 소트 머지 조인 제어하기
- 예시

  ![CleanShot 2024-08-22 at 20 40 41@2x](https://github.com/user-attachments/assets/eb03f75e-8cbe-40d6-8fd7-c7e8d49e71c7)

  - 해석: 양쪽 테이블을 각각 소트한 후, 위쪽 사원 테이블 기준으로 아래쪽 고객 테이블과 머지 조인한다
    - 소트할 대상을 찾기 위해 각 테이블을 액세스할 때 인덱스를 이용한다는 점을 확인 가능   

- 소트 머지 조인 실행 계획을 제어할 때 **`use_merge`** 힌트를 사용 

  ![CleanShot 2024-08-22 at 20 40 49@2x](https://github.com/user-attachments/assets/c7be8b52-6a21-481b-ae24-caad0877fe19)

### 4.2.6 소트 머지 조인 특징 요약
- **`양쪽 집합을 개별적으로 읽은 후 조인을 시작하는 방식`**
- 소트 머지 조인은 `조인을 위해 실시간으로 인덱스를 생성하는 것과 다름 없음`
- **`소트 부하만 감수한다면, 건건이 버퍼 캐시를 경유하는 NL 조인보다 빠름`**
- NL 조인은 조인 컬럼에 대한 인덱스 유무에 크게 영향을 받지만, **`소트 머지 조인은 (인덱스의) 영향을 받지 않음`**
- 조인 컬럼에 인덱스가 없는 상황에서 두 테이블을 각각 읽어 조인 대상 집합을 줄일 수 있을때 아주 유리함
- `스캔 위주의 액세스 방식을 사용함`
- 양쪽 소스 집합으로부터 조인 대상 레코드를 찾는데 인덱스를 이용할 수 있고, 그때는 랜덤 액세스가 일어남(해시 조인도 동일)

## 4.3 해시 조인
- NL 조인은 인덱스를 이용하는 방식이기 때문에, 인덱스 구성에 따른 성능 차이가 심함
  - 인덱스 구성을 아무리 잘하더라도 랜덤I/O의 한계로 대량 데이터 처리에 불리하며, 버퍼 캐시 히트율에 따라 성능이 오락가락함
- 소트 머지 조인과 해시 조인은 조인 과정에 인덱스를 이용하지 않기 때문에 대량 조인시에 NL 조인 보다 빠름 (일정한 성능)
- 소트 머지 조인은 양쪽 테이블을 정렬해야한다는 부담이 있는 반면, 해시 조인은 그러한 부담도 없음
- 다만, **해시 조인의 경우 특정 조건이 만족해야만 하기 때문에 모든 경우에 사용 가능하지 못하다는 단점이 있음**

### 4.3.1 기본 메커니즘
- 해시 조인도 소트 머지 조인과 유사하게 **`Build 단계`** 와 **`Probe 단계`** 두 단계로 진행됨
  - **`Build 단계`** : 작은 쪽 테이블(Build Input)을 읽어 해시 테이블(해시 맵)을 생성
  - **`Probe 단계`** : 큰 쪽 테이블을 읽어 해시 테이블을 탐색하면서 조인

- 해시 조인을 유도하기 위해서는 **`use_hash`** 힌트를 사용

  ![CleanShot 2024-08-31 at 02 16 48](https://github.com/user-attachments/assets/8f25c918-60e5-42cf-a9dd-1eb177ed0301)

- 조인 과정은 다음과 같음

  ![CleanShot 2024-08-31 at 02 21 47](https://github.com/user-attachments/assets/676ab1ef-6d23-4c8f-b0ec-98b286237e59)

  ![CleanShot 2024-08-31 at 02 17 19](https://github.com/user-attachments/assets/6e5b8efe-babb-4263-af06-5a8e2d103f1c)
  
  ![CleanShot 2024-08-31 at 02 22 14](https://github.com/user-attachments/assets/2b502c76-6297-4d04-a959-a5a022d9ac7e)

1. Build 단계에서 사원 데이터(작은 쪽 테이블)를 읽어 해시 테이블 생성. 조인 컬럼인 사원 번호를 해시 테이블의 키 값으로 사용
   - 해시 테이블은 PGA 영역에 할당된 Hash Area에 저장 (너무 커서 저장 못할시 Temp 테이블 스페이스에 저장)

2. Probe 단계에서 고객 데이터(큰 쪽 테이블) 하나씩 읽어 앞서 생성한 해시 테이블을 탐색. 관리 사원번호를 해시 함수에 입력해서 반환된 값으로 해시 체인을 찾고, 그 해시 체인을 스캔해서 값이 같은 사원번호를 찾음. 찾으면 성공(조인). 못찾으면 실패
   - Probe 단계의 작업은 NL 조인과 다를 바 없음을 확인 할 수 있음. 결국 루프를 돌면서 조인하는 방식 자체는 동일

### 4.3.2 해시 조인이 빠른 이유
- 해시 조인이 빠른 이유는 `소트 머지 조인이 빠른 이유와 동일함`
  -  **`해시 테이블을 PGA 영역에 할당하여, 조인하기 위해 조회시 더욱 효율적이기 때문`**

#### 소트 머지 조인 보다 빠른 이유
- 두 조인 메서드의 성능 차이는 조인 오퍼레이션을 시작하기 전, 사전 준비 작업에 있음
- 소트 머지 조인은 **`양쪽 테이블을 모두 정렬해야하기 때문에 PGA에 양쪽 테이블이 담김`** .
- 반면에, 해시 테이블은 **`한쪽 테이블만 해시 맵을 만들기 때문에 PGA에 담김 확률이 더욱 높음`**
- 따라서, 소트 머지 조인에 비해 Temp 테이블 스페이스(디스크)에 쓸일이 거의 없음
- 또한, 미리 정렬하는 부하도 없음
- 결론은 일반적인 상황에서 대량 데이터 조인 시에는 해시 조인이 가장 빠름


#### 해시 테이블에 담기는 정보
- 해시 테이블에 조인 키값만 저장된다고 알고 있는 경우가 있는데 이는 사실이 아님
- 키 값만 저장하게 되면 조인에 성공한 후에 다시 나머지 정보를 읽어 들이기 위해 테이블 블록을 읽어야 하는 비효율이 생김
- 따라서, **`키 값 뿐아니라 SQL에 사용한 컬럼 모두 저장함`**

### 4.3.3 대량 Build Input 처리
- 테이블이 너무 대용량이어서 인메모리에서 해시 조인이 불가능한 상황에 DBMS는 어떻게 조인할까?
  - 분할 정복 방식으로 문제를 해결함
  - 즉, **`파티션한 후 조인하는 방식`**

- 파티션 단계
  - 해시 함수를 적용하고 해시 값에 따라 동적으로 파티셔닝
  - 독립적으로 처리할 수 있는 여러 개의 작은 서브 집합으로 분할함으로서 파티션 짝을 생성

    ![CleanShot 2024-08-31 at 02 54 28](https://github.com/user-attachments/assets/e58776b8-d77c-41dd-8714-f20a293f0d28)

    - 양쪽 집합을 읽어 디스크(Temp)에 저장하기 때문에 성능이 떨어짐
   
- 조인 단계
  - 각 파티션 짝에 대해서 하나씩 조인을 수행한 후 합침

### 4.3.4 해시 조인 실행 계획 제어
- 실행 계획

  ![CleanShot 2024-08-31 at 02 45 23](https://github.com/user-attachments/assets/5c69e24d-6b85-42bc-a6cd-0d725474594f)

- use_hash 힌트로 해시 조인 유도

  ![CleanShot 2024-08-31 at 02 45 32](https://github.com/user-attachments/assets/74b90222-0fb3-4c8c-b831-3d11c35e67ed)

- Build Input 선택 → leading or ordered

  ![CleanShot 2024-08-31 at 02 47 03](https://github.com/user-attachments/assets/21683767-d483-49ec-9813-5364ea754263)

- swap_join_inputs 힌트로 Build Input을 명시적으로 선택할 수 있음

  ![CleanShot 2024-08-31 at 02 47 54](https://github.com/user-attachments/assets/69e09f43-27ac-413a-90a0-6ee30c8b8d5a)

### 4.3.5 조인 메서드 선택 기준
- 지금까지 3가지 조인 메서드를 보면 보통 해시 조인이 가장 빠르기 때문에 해시 조인을 사용해야한다고 생각하는 경우가 종종 있음
- 하지만, `보통의 경우(OLTP, 수행 빈도가 높음)라면 NL 조인을 사용하는 게 나음`
- **`각각의 조인 메서드는 목적이 있기 때문에 상황에 맞게 선택해야함`**

   ![CleanShot 2024-08-31 at 02 31 17](https://github.com/user-attachments/assets/27e41a40-39b4-45c3-8ec6-3dedbdeb5f12)

- 여기서 소량과 대량의 기준은?
  - `NL 조인 기준으로 최적화했음에도 랜덤 액세스가 많아서 만족할만한 성능을 낼 수 없는 경우` → **`대량`**
 
- 수행 빈도가 높은 경우에는 다음과 같은 기준도 확인해보는 것이 좋음
  - (최적화된) NL 조인과 해시 조인 성능이 같으면 → NL조인
  - 해시 조인이 약간 더 빨라도 → NL 조인
  - NL 조인보다 해시 조인이 매우 빠른 경우 → 해시 조인

- 즉, **`성능 차이가 엄청나게 나지 않는 경우가 아니라면 NL 조인을 사용하는 것이 나음`**
- 그러면 해시 조인이 빠름에도 NL 조인을 사용하기를 권장하는 이유는 뭘까?
  - NL 조인에 사용하는 인덱스는 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용하는 자료구조임
  - 반면에, **`해시 테이블은 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸되는 자료구조임`**
  - **`쿼리가 여러번 반복될수로 CPU, 메모리 사용률이 크게 증가하는 문제가 생김(속도는 보다 빠를지라도)`**

- 따라서, 해시 조인을 사용하기 전에 아래와 같은 상황인지 먼저 확인해야함
  - 수행 빈도가 낮은지
  - 쿼리 수행 시간이 오래 걸리는지
  - 대량 데이터를 조인하는지
  - 이는, DW, OLAP성 쿼리의 특징이기도 함(배치 쿼리)

## 4.4 서브쿼리 조인
- 서브쿼리 조인을 이해하기 위해서는 쿼리 변환을 이해해야함
  - 옵티마이저가 서브쿼리에 대해 다양한 형태로 쿼리 변환을 시도하기 때문 

### 4.4.4 서브쿼리 변환이 필요한 이유
- SQL은 동일한 결과를 내는 다양한 형태가 존재함. 다만, 어떤 것을 선택하느냐에 따라 성능이 달라질 수 있음
- 따라서, 옵티마이저는 비용을 평가하고 실행계획을 생성하기 이전에 SQL을 최적화에 유리한 형태로 변환하는 쿼리 변환을 시도함
  - 쿼리 변환 : 의미적으로 동일(동일한 결과 집합)하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것

- 서브 쿼리는 하나의 SQL 문 안에 괄호로 묶은 별도의 쿼리 블록을 말함(쿼리에 내장된 또 다른 쿼리) 

  ![CleanShot 2024-08-31 at 03 04 54](https://github.com/user-attachments/assets/e0b70533-e5ee-4bb2-b5cb-777bebe736b9)

- 옵티마이저가 쿼리를 변환하지 않고 그대로 수행하면, 각각의 블록 단위로 최적화를 진행함
  - 이는 올바르게 최적화가 되었다고 보기 어려움(전체 맥락을 고려한 최적화 방안이 아니기 때문)
  - 따라서, 옵티마이저는 서브쿼리를 풀어내려고 시도함 

### 4.4.2 서브 쿼리와 조인
- 메인 쿼리와 서브 쿼리 간에는 종속적이고 계층적인 관계가 존재함
  - 메인 쿼리 건수 만큼 값을 받아 반복적으로 필터링하는 방식으로 실행해야 함
 
#### 필터 오퍼레이션
- 서브 쿼리를 필터 방식으로 처리할 때의 실행 계획

  ![CleanShot 2024-08-31 at 03 10 36](https://github.com/user-attachments/assets/4e0e3534-9386-47b5-ad3a-40672f10e2ce)

  - FILTER를 NESTED LOOP로 치환해서 생각하면 됨(동일한 과정)
    - 다만, 차이가 있는데 필터는 메인쿼리의 한 로우가 서브쿼리의 한 로우와 조인에 성공하는 순간 진행을 멈추고 메인 쿼리의 다음 로우를 계속 처리
    - 이렇게 해야 메인 쿼리 결과 집합이 서브 쿼리 집합 수준으로 확장된느 현상을 막을 수 있음
    - 또 하나의 차이 점은 필터는 캐싱 기능을 가짐. 서브 쿼리를 수행하지 않도록 하여 성능을 높이는데 도움이 됨
    - 그리고 필터 서브 쿼리는 일반 NL 조인과 달리 메인 쿼리에 종속되므로 조인 순서가 고정됨(메인 쿼리가 드라이빙)

#### 서브쿼리 Unnesting
- 서브 쿼리를 Unnesting 할 때의 실행 계획
  - 보통은 옵티마이저가 Unnesting을 선택하지만, 명시적으로 유도하기 위해서는 unnest 힌트를 사용함 

  ![CleanShot 2024-08-31 at 03 14 48](https://github.com/user-attachments/assets/336ba0ee-0c0f-4746-a881-53ae7a01c96e)

  - Unnesting란, 메인과 서브 쿼리 간의 계층 구조를 풀어 서로 같은 레벨(Flat)로 만들어 준다는 의미(서브쿼리 Flatting)
  - 필터 오퍼레이션과 유사하지만 다른 부분은 서브 쿼리를 Unnesting하면 일반 조인문 처럼 다양한 최적화 기법을 적용할 수 있게됨
  - 또한, 메인 쿼리가 반드시 드라이빙이 되는 것이 아님
  - 따라서, 옵티마이저는 많은 조인 테크닉을 가질 수 있게 되므로 Unnesting 했을때 더 좋은 실행 경로를 찾을 가능성이 높음
 
#### 서브쿼리 Pushing
- 서브쿼리 필터링을 먼저 처리함으로써 조인 단계로 넘어가는 로우 수를 크게 줄일 수 있다면 성능은 그만큼 향상됨
- 서브쿼리 필터링을 먼저 처리하게끔 하고자 한다면 push_subq 힌트를 사용하면 됨

- Pushing 서브 쿼리는 이처럼 서브쿼리 필터링을 가능한 한 앞 단계에서 처리하도록 강제하는 기능이며, push_subq/no_push_subq 힌트로 제어가 가능함
  - 해당 기능은 Unnesting 되지 않은 서브쿼리에만 작동함. 따라서, push_subq 힌트는 항상 no_unnest 힌트와 같이 기술하는 것이 올바른 사용법임
 

 ### 4.4.3 뷰(View)와 조인
- 옵티마이저가 뷰 쿼리를 변환하지 않으면 뷰 쿼리 블록을 독립적으로 최적화함
- merge 힌트를 이용해 뷰를 메인 쿼리와 머징(Merging)하도록 할 수 있음 (반대는 no_merge)

#### 조인 조건 Pushdown
- 메인 쿼리를 실행하면서 조인 조건절 값을 건건이 뷰 안으로 밀어 넣는 기능

### 4.4.4 스칼라 서브쿼리 조인

#### 스칼라 서브쿼리의 특징
- 함수 안에 있는 서브쿼리를 메인 쿼리 건수 만큼 반복 실행하게됨
- 메인 쿼리 레코드 마다 정확히 하나의 값만 반환함
- 처리 과정에서 캐싱 작용이 있음

#### 스칼라 서브쿼리 캐싱 효과
- 스칼라 서브쿼리로 조인하면 오라클은 조인 횟수를 최소화하기 위해 입력값과 출력 값을 내부 캐시에 저장해둠

#### 스칼라 서브쿼리 캐싱 부작용
- 캐시 공간이 부족하기 때문에, 입력 값의 종류가 소수여서 해시 충돌 가능성이 적은 경우에 효과적
- 그게 아니라면 캐시를 매번 확인하는 비용때문에 성능이 나빠지고 CPU/메모리 사용률만 높게 만듬
- 메인 쿼리 집합이 매우 작은 경우에도 비효율적(해당 캐싱은 쿼리 단위로 쓰고 버리기 때문 - 캐시의 재상용성이 낮음)

