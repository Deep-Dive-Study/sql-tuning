# 1장 SQL 처리 과정과 I/O

# 1.1 SQL 파싱과 최적화

## 1.1.1 구조적, 집합적, 선언적 질의 언어

SQL : Structured Query Language의 줄임말로서 구조적, 집합적, 선언적 질의 언어이다.

## 1.1.2 SQL 최적화

SQL 실행 최적화 과정

### 1. SQL 파싱

사용자로부터 SQL을 전달받은 뒤 SQL 파서가 파싱한다.

- 파싱 트리 생성 : SQL문을 이루는 개별 구성요소를 분석해서 트리 생성
- Syntax 체크 : 문법적 오류가 없는지 확인하고, 올바르지 않은 키워드나 누락된 키워드 확인
- Semantic 체크 : 의미상 오류 확인 / 테이블 존재 유무, 오브젝트 권한 유무

### 2. SQL 최적화

옵티마이저는 미리 수집한 통계정보를 바탕으로 다양한 실행경로를 생성해서 가장 효율적인 하나를 선택한다.

데이터베이스 성능의 핵심은 옵티마이저이다.

### 3. 로우 소스 생성

SQL 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포매팅 한다.

로우 소스 생성기가 그 역할을 한다.

## 1.1.3 SQL 옵티마이저

옵티마이저의 최적화 단계

1. 사용자로부터 전달받은 쿼리 수행 후보 계획들을 찾아낸다.
2. 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계를 이용해 각 실행계획의 예상비용을 산정한다.
3. 예상비용이 최저인 실행계획을 선택한다.

![image](https://github.com/Deep-Dive-Study/sql-tuning/assets/85796588/4bf59014-95aa-454d-8c04-7cfeabe15654)

## 1.1.4 실행계획과 비용

SQL 실행계획을 확인한 뒤 원하는대로 실행경로를 변경할 수 있다. (쿼리 앞에 Explain)

![image](https://github.com/Deep-Dive-Study/sql-tuning/assets/85796588/0047487f-5a57-4d11-8f82-f751f7f24f26)

옵티마이저가 실행계획을 선택하는 근거 = Cost (예측치)

## 1.1.5 옵티마이저 힌트

옵티마이저가 결정한 실행계획이 마음에 들지 않을 때 (인덱스를 안탄다거나) 힌트로 원하는대로 변경할 수 있다.

```java
SELECT /*+ INDEX(A PK) */
	컬럼, 컬럼, 컬럼
FROM 테이블 A
WHERE ID = ??
```

### 주의사항

- 힌트 안에 인자를 나열할 때 ,를 사용해도 되지만 힌트와 힌트 사이에는 안된다
    
    ```java
    /*+ INDEX(A A인덱스) INDEX(B, B인덱스) */ -> 모두 유효
    /*+ INDEX(C), FULL(D) */ -> C만 유효
    ```
    
- FROM 절 테이블에 ALIAS를 지정했다면, 힌트에도 ALIAS를 사용해야 한다.
    
    ```java
    SELECT /*+ FULL (EMP) */ -> 유효하지 않음
    FROM EMP E
    ```
    

### 자율 or 강제

- 자율 : 주요 힌트만 지정
    
    ```java
    SELECT /*+ INDEX(A (주문일)) */
    	컬럼, 컬럼, 컬럼
    FROM 주문 A, 고객 B
    WHERE A.주문일 = ??
    	AND A.고객ID = B.고객ID
    ```
    
- 강제 : 힌트부터 조인 방식과 순서 및 엑세스 방식까지 지정
    
    ```java
    SELECT /*+ LEADING(A) USE_NL(B) INDEX(A (주문일)) INDEX(B 고객PK) */
    	컬럼, 컬럼, 컬럼
    FROM 주문 A, 고객 B
    WHERE A.주문일 = ??
    	AND A.고객ID = B.고객ID
    ```
    

자율의 경우, 옵티마이저가 가끔 실수를 하게 되면 기업에 큰 손실을 끼치기도 한다. **힌트는 빈틈없이**

### 자주 사용하는 힌트 목록

![image](https://github.com/Deep-Dive-Study/sql-tuning/assets/85796588/387d8bd4-a3e2-4ead-a565-3dc4134e3a1f)

![image](https://github.com/Deep-Dive-Study/sql-tuning/assets/85796588/e2148184-4d23-4da3-8a26-e0a686a3ba52)

# 1.2 SQL 공유 및 재사용

SQL 최적화의 복잡성을 알게되면, 동시성이 높은 온라인 트랜잭션 처리에서 바인드 변수의 중요성을 알 수 있다.

## 1.2.1 소프트 파싱 vs 하드 파싱

* 라이브러리 캐시 : SQL 파싱, 최적화, 로우 소스 생성을 재사용 하기위해 캐싱한 메모리 공간 (SGA의 요소)

* SGA : System Global Area의 약자로 서버 프로세스와 백그라운드 프로세스가 공통으로 엑세스하는 데이터와 제어 구조를 캐싱하는 **메모리 공간**

![image](https://github.com/Deep-Dive-Study/sql-tuning/assets/85796588/9dd9c358-fbc9-4a40-81f2-8a0480e5a6fa)

1. 사용자가 SQL을 파싱한다.
2. 라이브러리 캐시에 존재 여부를 확인한다.
    1. 존재하면 실행 한다. (소프트 파싱)
3. 존재하지 않으면 최적화 및 로우 소스를 생성한다. (하드 파싱)

![image](https://github.com/Deep-Dive-Study/sql-tuning/assets/85796588/1ab13769-7e00-424f-b1a8-0f6900cb4dee)

### SQL 최적화 과정이 하드한 이유

여러 실행 계획을 고려하고, 최적의 경로를 선정하는 것은 생각보다 많은 일을 수행해야 한다.

- 테이블, 컬럼, 인덱스 구조 정보
- 오브젝트 통계 - 테이블 통계, 인덱스 통계, 컬럼 통계 (히스토그램 포함)
- 시스템 통계 - CPU, Single Block I/O, Multiblock I/O 속도 등
- 옵티마이저 관련 파라미터

하드 파싱은 CPU를 많이 소비하는 몇 안되는 작업 중 하나이다. 따라서 캐싱이 없다면, 매우 아까울 것이다.

## 1.2.2 바인드 변수의 중요성

### 이름 없는 SQL 문제

함수/프로시저, 트리거, 패키지 등은 생성할 때부터 이름을 가져 딕셔너리에 저장되고, 라이브러리 캐시에 적재도 된다. 반면에 SQL은 이름이 없어 딕셔너리에 저장하지 않는다. SQL 자체가 이름이 되어 라이브러리 캐시에 적재되긴 하지만, 공간이 부족하면 버려진다.

SQL도 영구 저장하는 방법이 있을까? (IBM DB2 제외하곤 그렇지 않고있음)

SQL은 이름이 없어 조그마한 수정만 일어나도 다른 객체가 탄생한다. Oracle 10g의 SQL ID를 사용해도 이름이 매번 변화하기에 소용없다.

### 공유 가능 SQL

```java
SELECT * FROM TABLE WHERE COLUMN = ?
```

위의 쿼리에서 ?에 들어갈 단어가 매번 바뀌면 모두 다른 SQL이 되어 라이브러리 캐시에 가득차게 된다.

그렇다면 파라미터를 받는 프로시저를 만들어 재사용하면 되지 않을까?

```java
create procedure SQL (variable in varchar2) { ... }
```

이처럼 파라미터 Driven 방식으로 사용하면 SQL에 대한 하드파싱은 줄어들고 재사용하게 된다.

→ 실제 우리회사에서 로그인/아웃 관련 SQL을 프로시저로 사용중인데 이거때문일까?

→ 그럼 왜 최근 기업들은 자바로 옮기려는 행동을 보이는걸까?
