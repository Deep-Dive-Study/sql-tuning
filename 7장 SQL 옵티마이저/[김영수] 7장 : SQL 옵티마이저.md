# 7장. SQL 옵티마이저

## 7.1 통계정보와 비용 계산 원리

### 7.1.1 선택도와 카디널리티

선택도 : 전체 레코드 중 조건절에 의해 선택되는 레코드 비율

선택도 = 1 / NDV (Number of distinct values, 컬럼 값 종류 개수)

카디널리티 : 전체 레코드 중 조건절에 의해 선택되는 레코드 개수

카디널리티 = 총 로우 수 x 선택도 = 총 로우 수 / NDV



옵티마이저는 카디널리티와 선택도를 이용해서 액세스와 조인 방식을 선택하므로 통계 정보 수집 과정에서 정확히 구해야 한다 .

### 7.1.2 통계정보

오브젝트 통계 시스템 통계가 있다.

오브젝트 통계는 테이블, 인덱스, 컬럼, 히스토그램 통계로 나뉜다

#### 테이블 통계

테이블 통게 수집 명령어

```sql
begin
  dbms_stats.gather_table_stats('scott', 'emp');
end;

// mysql
ANALYZE TABLE 테이블명;

// postgresql
ANALYZE [VERBOSE] 테이블명;
```

#### 인덱스 통계

```sql
begin
  dbms_stats.gather_index_stats (ownname => 'scott', indname => 'emp_x01')
end;

// mysql
ANALYZE TABLE 테이블명;

// postgresql
ANALYZE [VERBOSE] 테이블명;
```



### 7.1.3 비용 계산 원리

## 1. Oracle 옵티마이저의 비용 계산 원리

### **개요**

Oracle의 옵티마이저는 **비용 기반 옵티마이저(Cost-Based Optimizer, CBO)**로, 다양한 실행 계획의 비용을 비교하여 가장 효율적인 계획을 선택합니다. 비용 계산은 주로 **I/O 비용**과 **CPU 비용**을 기반으로 하며, 통계 정보를 활용하여 보다 정확한 비용 추정을 합니다.

### **비용 계산 요소**

1. **I/O 비용**: 데이터 블록을 디스크에서 읽거나 쓰는 데 필요한 비용.
2. **CPU 비용**: 데이터 처리에 필요한 CPU 시간.

### **통계 정보의 활용**

- **테이블 통계**: 행(row)의 수, 블록(block)의 수, 평균 행 길이 등.
- **인덱스 통계**: 인덱스의 깊이(depth), 리프 블록 수, 클러스터링 팩터 등.
- **컬럼 통계**: 각 컬럼의 분포도, 고유 값 수 등.
- **히스토그램**: 데이터 분포가 불균등한 컬럼에 대해 상세한 분포 정보를 제공.

### **비용 계산의 원리**

1. **가능한 모든 실행 계획 생성**: 옵티마이저는 쿼리에 대한 가능한 모든 실행 계획을 생성합니다.

2. 각 실행 계획의 비용 계산

   :

   - **I/O 비용 계산**: 예상되는 데이터 액세스 패턴에 따라 디스크 I/O 횟수를 추정합니다.
   - **CPU 비용 계산**: 각 연산(예: 조인, 필터링)에 필요한 CPU 시간을 추정합니다.

3. **총 비용 산출**: I/O 비용과 CPU 비용을 합산하여 각 실행 계획의 총 비용을 계산합니다.

4. **최적의 실행 계획 선택**: 총 비용이 가장 낮은 실행 계획을 선택합니다.

### **예시**

- 테이블 스캔 vs. 인덱스 스캔

  :

  - 작은 테이블의 경우 전체 테이블 스캔이 비용이 더 낮을 수 있습니다.
  - 대형 테이블에서 조건절에 인덱스를 사용할 수 있다면 인덱스 스캔의 비용이 낮아집니다.

- 조인 순서 결정

  :

  - 옵티마이저는 조인되는 테이블의 크기와 조건을 고려하여 조인 순서를 결정합니다.

### **최적화 단계**

1. **파싱(Parsing)**: SQL 문법 검사 및 파싱 트리 생성.
2. **바인딩(Binding)**: 객체의 실제 존재 여부 및 권한 검사.
3. **최적화(Optimization)**: 실행 계획 생성 및 비용 계산.
4. **실행(Execution)**: 선택된 실행 계획에 따라 쿼리 실행.

### **추가 정보**

- **옵티마이저 힌트**: 개발자는 힌트를 사용하여 옵티마이저의 결정에 영향을 줄 수 있습니다.
- **동적 샘플링**: 통계 정보가 부족한 경우 실행 시점에 샘플링을 통해 통계를 수집합니다.
- **자동 통계 수집**: Oracle은 자동으로 통계를 수집하여 최신 상태로 유지합니다.

------

## 2. MySQL 옵티마이저의 비용 계산 원리

### **개요**

MySQL의 옵티마이저는 비용 기반 옵티마이저로, 다양한 실행 계획의 비용을 계산하여 최적의 계획을 선택합니다. 그러나 MySQL의 비용 모델은 상대적으로 단순하며, 주로 **I/O 작업 수**를 기반으로 비용을 추정합니다.

### **비용 계산 요소**

1. **디스크 I/O 비용**: 디스크에서 데이터를 읽는 데 필요한 작업 수.
2. **메모리 비용**: 메모리 내에서의 연산 비용은 일반적으로 무시됩니다.
3. **네트워크 비용**: 분산 환경에서의 네트워크 비용은 고려되지 않습니다.

### **통계 정보의 활용**

- **테이블 통계**: 행의 수, 인덱스의 카디널리티 등.
- **인덱스 통계**: 인덱스의 고유 값 수.
- **컬럼 통계**: MySQL 8.0부터는 히스토그램을 사용하여 컬럼의 데이터 분포를 파악할 수 있습니다.

### **비용 계산의 원리**

1. **실행 계획 생성**: 가능한 조인 순서, 인덱스 사용 여부 등을 고려하여 실행 계획을 생성합니다.

2. 각 실행 계획의 비용 계산

   :

   - **액세스 비용**: 테이블 또는 인덱스를 액세스하는 데 필요한 예상 작업 수.
   - **필터링 효과**: WHERE 절의 조건에 따라 필터링되는 행의 수를 추정.

3. **비용 비교 및 계획 선택**: 가장 낮은 비용의 실행 계획을 선택합니다.

### **예시**

- 인덱스 선택

  :

  - 옵티마이저는 각 인덱스의 선택도(selectivity)를 평가하여 가장 효율적인 인덱스를 선택합니다.

- 조인 순서 결정

  :

  - 작은 테이블을 먼저 읽고, 그 결과를 기반으로 큰 테이블과 조인하는 것이 일반적입니다.

### **제한사항 및 특징**

- **간단한 비용 모델**: MySQL의 비용 모델은 Oracle이나 PostgreSQL에 비해 단순하여 복잡한 쿼리에 대한 최적화가 제한될 수 있습니다.
- **통계 정보의 한계**: 통계 정보가 부족하면 옵티마이저가 비효율적인 실행 계획을 선택할 수 있습니다.
- **힌트 지원 제한**: MySQL은 옵티마이저 힌트를 일부 지원하지만, 기능이 제한적입니다.

### **최적화 단계**

1. **파싱 및 전처리**: SQL 문법 검사 및 전처리.
2. **실행 계획 생성**: 가능한 실행 계획 생성.
3. **비용 계산 및 최적화**: 각 계획의 비용 계산 및 최적의 계획 선택.
4. **실행**: 선택된 실행 계획에 따라 쿼리 실행.

------

## 3. PostgreSQL 옵티마이저의 비용 계산 원리

### **개요**

PostgreSQL의 옵티마이저는 강력한 비용 기반 옵티마이저로, 다양한 실행 계획의 비용을 세밀하게 계산합니다. 비용 계산은 **I/O 비용**, **CPU 비용**, **메모리 비용** 등을 종합적으로 고려합니다.

### **비용 계산 요소**

1. **I/O 비용**: 디스크 블록을 읽고 쓰는 비용.
2. **CPU 비용**: 각 연산에 필요한 CPU 시간.
3. **메모리 비용**: 메모리 내에서 작업하는 데 필요한 비용.
4. **병렬 처리 비용**: 병렬 실행 시의 오버헤드 및 효율성.

### **통계 정보의 활용**

- **테이블 통계**: 행의 수, 페이지 수, 평균 행 길이 등.
- **인덱스 통계**: 인덱스의 깊이, 페이지 수 등.
- **컬럼 통계**: 컬럼의 고유 값 수, NULL 비율, 가장 흔한 값(MCV), 히스토그램 등.
- **히스토그램 및 MCV(Most Common Values)**: 데이터 분포를 상세하게 파악하여 비용 계산에 활용.

### **비용 계산의 원리**

1. 가능한 실행 계획 생성

   :

   - 조인 방법(Nested Loop, Hash Join, Merge Join 등), 조인 순서, 인덱스 사용 여부 등을 고려.

2. 각 실행 계획의 비용 계산

   :

   - **I/O 비용**: 페이지 수 * 랜덤/순차 I/O 비용 계수.

   - **CPU 비용**: 튜플 처리 수 * 연산당 CPU 비용 계수.

   - 총 비용 = 시작 비용 + 실행 비용

     :

     - **시작 비용**: 쿼리를 시작하는 데 필요한 초기 비용.
     - **실행 비용**: 쿼리를 완료하는 데 필요한 총 비용.

3. 통계 정보 활용

   :

   - 데이터 분포에 따른 카디널리티 추정.
   - 필터 조건의 선택도 추정.

4. **비용 비교 및 최적의 실행 계획 선택**.

### **예시**

- 조인 방법 선택

  :

  - 작은 테이블과의 조인은 Nested Loop를 사용하고, 큰 테이블 간 조인은 Hash Join을 선택할 수 있습니다.

- 인덱스 스캔 vs. 시퀀셜 스캔

  :

  - 테이블의 크기와 조건절의 선택도를 고려하여 인덱스 사용 여부 결정.

### **옵티마이저 파라미터**

- **random_page_cost**: 랜덤 I/O의 비용 계수.
- **seq_page_cost**: 순차 I/O의 비용 계수.
- **cpu_tuple_cost**: 튜플을 처리하는 데 필요한 CPU 비용.
- **cpu_index_tuple_cost**: 인덱스 튜플을 처리하는 데 필요한 CPU 비용.
- **cpu_operator_cost**: 연산자 처리에 필요한 CPU 비용.

### **병렬 쿼리 최적화**

- PostgreSQL은 병렬 쿼리를 지원하며, 병렬 실행 시의 비용도 계산에 포함합니다.
- **parallel_setup_cost**: 병렬 실행을 설정하는 데 필요한 비용.
- **parallel_tuple_cost**: 병렬 실행 시 튜플을 처리하는 비용.

### **최적화 단계**

1. **파싱(Parsing)**: SQL 문법 검사 및 파싱 트리 생성.

2. **재작성(Rewriting)**: 뷰 또는 규칙을 적용하여 쿼리 트리 재작성.

3. 플래너/옵티마이저(Planning/Optimization)

   :

   - 가능한 실행 계획 생성.
   - 비용 계산 및 최적의 계획 선택.

4. **실행(Execution)**: 선택된 실행 계획에 따라 쿼리 실행.

결론

- **Oracle**:
  - 복잡하고 정교한 비용 모델을 사용.
  - 다양한 통계 정보와 히스토그램을 활용하여 정확한 비용 계산.
  - 옵티마이저 힌트 및 동적 샘플링 등으로 최적화 가능.
- **MySQL**:
  - 비교적 단순한 비용 모델 사용.
  - 주로 디스크 I/O 작업 수를 기반으로 비용 계산.
  - 통계 정보의 한계로 인해 복잡한 쿼리 최적화에 제한이 있을 수 있음.
- **PostgreSQL**:
  - 세밀하고 유연한 비용 모델 사용.
  - 다양한 통계 정보와 히스토그램, MCV 등을 활용.
  - 파라미터 조정을 통해 옵티마이저의 행동을 세밀하게 제어 가능.

### **공통점**

- 모두 비용 기반 옵티마이저를 사용하여 실행 계획의 비용을 계산하고, 가장 효율적인 계획을 선택합니다.
- 통계 정보의 정확성이 쿼리 최적화에 큰 영향을 미칩니다.



## 7.2 옵티마이저에 대한 이해

### 7.2.1 옵티마이저 종류

Cost-based(비용기반) 옵티마이저 : 실행계획을 도출하고 통계정보를 이용해 각 실행계획의 예상비용을 산정하고 그중 가장 낮은 비용의 실행 계획을 선택해 실행하는 옵티마이저

role-based(규칙기반) 옵티마이저 : 과거에 사용. 단순한 규칙에만 의존함.



### 7.2.2 옵티마이저 모드

비용기반 옵티마이저에는 최적화 목표를 설정하는 기능이 있다. 아래 세 가지중 하나를 선택하면 된다

- ﻿﻿ALL_ROWS : 전체 처리속도 최적화
    - 쿼리 결과집합 전체를 읽어, cpu, io, memory등 가장 적게 사용하는 실행계획을 선택하여 전체 처리속도 최적화를 목표로 함
- ﻿﻿FIRST_ROWS : 최초 응답속도 최적화
    - 앞쪽 일부만 읽다가 멈추는것을 목표로 응답속도가 가장 빠른 실행계획 선택 
- ﻿﻿FIRST_ROWS_N : 최초 N건 응답속도 최적화
    - 앞쪽 N개 로우만 읽고 멈추는것을 전제로 응답속도가 가장 빠른 실행계획을 선택한다. 



### 7.2.3 옵티마이저에 영향을 미치는 요소

(1)SQL과 연산자 형태

결과가 같더라도 SQL을 어떤 형태로 작성했는지 또는 어떤 연산자(=, IN, LIKE, BETWEEN, 부등호 등)를 사용했는지에 따라 옵티마이저가 다른 선택을 할 수 있고, 궁극적으로 쿼리 성능 에 영향을 미친다.

(2)인덱스, IOT, 클러스터, 파티션, MV 등 옵티마이징 팩터 쿼리를 똑같이 작성해도 인덱스, IOT, 클러스터, 파티션, MV 등을 구성했는지, 그리고 어떤 식으로 구성했는지에 따라 실행계획과 성능이 크게 달라진다.

(3)﻿﻿﻿﻿제약 설정

DBMS에 설정한 PK, FK, Check, Not Null 같은 제약(Constraint)들은 데이터 무결성을 보 장해 줄뿐만 아니라 옵티마이저가 쿼리 성능을 최적화하는 데 매우 중요한 메타 정보로 활용 된다.

(4)통계 정보

(5)옵티마이저 힌트

가장 절대적인 영향을 미치는 요소. 힌트를 명령어로 인식하고 바로 따르지만 제대로 작동하지 않으면 아래 문제일 경우가 높다

1. ﻿﻿﻿문법적으로 맞지 않게 힌트를 기술
2. ﻿﻿﻿잘못된 참조 사용
3. ﻿﻿﻿의미적으로 맞지 않게 힌트를 기술
4. ﻿﻿﻿논리적으로 불가능한 액세스 경로
5. ﻿﻿﻿버그

### 7.2.4 옵티마이저의 한계

아무리 통계 정보를 잘 수집하고 SQL을 잘 작성해도 실수가 있을수 있다.

그리고 DBMS도 버전에 따라 다르기 때문에 항상 최적화는 불가능하다.

SQL 최적화 기법이 과거와 비교하면 아주 많이 좋아졌고 계속 발전하는 중이지만, 위와 같 은 한계와 제약으로 인해 앞으로도 옵티마이저는 불완전할 수밖에 없다.

### 7.2.5 개발자의 역할

고성능, 고효율 DB 애플리케이션을 구축하려면, 소수 DBA나 튜너보다 다수 개발자 역할이 더 중요하다. 따라서 새로운 개발 언어를 익히는 노력 이상으로 SQL 수행원리와 튜닝방법을 익히는 데도 많은 노력과 시간을 투자해야 한다. 프로그램 수행 결과뿐만 아니라 "SQL 성능 도 내가 지킨다"는 장인정신이 필요하다고 하겠다.

기본적으로 옵티마이저에게 많은 일을 맡기는 RDBMS 환경에서 SQL 성능을 높이기 위해 개발차가 할 일은 다음과 같다.

- ﻿﻿필요한 최소 블록만 읽도록 쿼리를 작성한다.
- ﻿﻿최적의 옵티마이징 팩터를 제공한다.
- ﻿﻿필요하다면, 옵티마이저 힌트를 사용해 최적의 액세스 경로로 유도한다.
