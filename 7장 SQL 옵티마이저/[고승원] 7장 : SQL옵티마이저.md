# 7.1 통계정보와 비용 계산 원리

## 7.1.1 선택도와 카디널리티

* 선택도 : 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율을 말한다. (1/NDV)

* 카디널리티 : 전체 레코드 중에서 조건절에 의해 선택되는 레코드 개수. (총 로우수/NDV)

한 컬럼에 값이 가, 나, 다, 라 네가지가 있을 때 한 컬럼에 대한 선택도는 25%, 카디널리티는 4/레코드 수 이다.

옵티마이저는 이렇게 카디널리티를 구하고 비용을 계산해서 테이블 액세스, 조인 방식 등을 결정한다.

선택도를 잘못 계산하면, 카디널리티와 비용도 잘못 계산하고, 결과적으로 비효율적인 액세스 방식과 조인 방식을 선택하게 된다.

## 7.1.2 통계정보

### 1. 테이블 통계

```sql
begin
	dbms_stats.gather_table_stats('scott', 'emp');
end;
```

![image](https://github.com/user-attachments/assets/e70151c2-d5cb-4a52-a592-c0f9eecb377e)

### 2. 인덱스 통계

```sql
begin
	dbms_stats.gather_index_stats ( ownname => 'scott', indname => '이름' );
end;
```

![image](https://github.com/user-attachments/assets/83a7e073-de35-4aa6-bee3-046c7ed3ea75)

### 3. 컬럼 통계

컬럼 통계는 테이블 통계시에 같이 수집된다.

![image](https://github.com/user-attachments/assets/e1c6da86-401d-4e1d-945e-e4e5b4331e29)

### 컬럼 히스토그램

= 조건에 대한 선택도는 1/NUM_DISTINCT 공식으로 구하거나, DENSITY 값을 이용하면 된다.

선택도를 잘못 구하면 데이터 액세스 비용을 잘못 산정하게 되고, 결국 최적이 아닌 실행계획으로 이어진다.

![image](https://github.com/user-attachments/assets/7bc4a12a-9abb-466c-8ca7-f857125a1a12)

```sql
begin
	dbms_stats.gather_table_stats('scott', 'emp', cascade=>false
		, method_opt=>'for columns ename size 10, deptno size 4');
end;
```

### 4. 시스템 통계

애플리케이션 및 하드웨어 성능 측정 표이며 주로 다음과 같은 지표가 있다.

- CPU 속도
- Single Block I/O 속도
- Multiblock I/O 속도
- block I/O 개수
- I/O 서브시스템 최대 처리량
- 병렬 Slave 평균 처리량

## 7.1.3 비용 계산 원리

비용모델은 I/O, CPU등으로 나뉘는데, 어떤 모델이냐에 따라 I/O콜 횟수, Single, Multiblock의 상대적인 수치일 수 있다.

- 인덱스 키값을 모두 = 조건으로 검색할 때
    - 비용 = BLEVEL + AVG_LEAF_BLOCKS_PER_KEY + AVG_DATA_BLOCKS_PER_KEY
- 인덱스 키값이 모두 = 조건이 아닐 때
    - 비용 = BLEVEL + LEAF_BLOCKS * 유효 인덱스 선택도 + CLUSTERING_FACTOR * 유효 테이블 선택도


# 7.2 옵티마이저에 대한 이해

## 7.2.1 옵티마이저 종류

- 비용기반 옵티마이저 (CBO)
    
    데이터 딕셔너리에 미리 수집해 둔 통계정보를 이용해 각 실행계획의 예상비용을 산정하고, 낮은 비용의 실행계획을 선택
    
- 규칙기반 옵티마이저 (RBO)
    
    규칙에 의존하여 산정한다. 이는 대량 데이터 처리에 비적합하다. (근래에는 비효율적이어서 쓰이지 않음)
    
    - 우선순위 규칙이 있는데, 비효율 적인 상황이 많이 발생해서이다.
 
## 7.2.2 옵티마이저 모드

옵티마이저 모드 종류

- ALL_ROWS : 전체 처리속도 최적화
    - CPU, I/O를 최적화 하는 방향으로 튜닝한다.
- FIRST_ROWS : 최초 응답속도 최적화
    - ALL_ROWS와 비교하면 Full Table Scan보다 Index, 다른 조인보다 NL조인을 선택한다.
- FIRST_ROWS_N : 최초 N건 응답속도 최적화
    - 모드 설정은 1, 10, 100, 1000 가능
    - 힌트에는 정수 사용 가능

## 7.2.3 옵티마이저에 영향을 미치는 요소

1. SQL과 연산자 형태 (=, IN, LIKE, BETWEEN 등)
2. 인덱스, IOT, 클러스터, 파티션, MV 등
3. 제약설정 (PK, FK, Check, Not Null 등)
4. 통계정보 (통계 정보가 문제가 생기면 애플리케이션 성능에 문제 발생)
    1. 통계정보 삭제
    2. 대량 데이터 수정 전에 통계정보 수집
    3. 통계정보 갱신않다가 갑자기 재수집
    4. 통계정보 없이 관리하던 테이블에 인덱스 재생성
    5. 테이블이나 인덱스 재생성하며, 파티션 단위로만 통계정보 수집
5. 옵티마이저 힌트
6. 옵티마이저 관련 파라미터 (파라미터, 기본값 변경 등)

## 7.2.4 옵티마이저의 한계

옵티마이저는 보편적으로 좋은 선택을 하지만, **항상** 최선의 선택은 아니다.

- 통계정보를 충분히 수집하는게 불가능하다. (수집/관리의 어려움)
- 컬럼 히스토그램 활용이 어려움

## 7.2.5 개발자의 역할

옵티마이저의 한계를 이해하고 활용해야 한다.
옵티마이저에 의존하지 않고, 개발자가 옵티마이징을 해야한다.

늘 실행계획을 통해 점검하고, 개선 여지를 확인한다.

- 필요한 최소 블록만 읽도록 한다.
    
    페이징, 스칼라 서브쿼리, 조인 순서 등
    
- 최적의 옵티마이징 팩터를 제공한다.
    
    인덱스 구성, DBMS 기능 활용, 옵티마이저 모드, 정확한 통계정보
    
- 옵티마이저 힌트를 사용해 최적의 액세스 경로로 유도한다.
    
    실행계획이 완벽하지 않으면, 직접 설정해주면 된다.

## 7.2.6 튜닝 전문가 되는 공부방법

### 데이터베이스 튜닝이란?
일반적으로 **성능**튜닝을 말한다.

![image](https://github.com/user-attachments/assets/11d09611-4e8c-4760-85c9-1e57bef4ba4a)


1. SQL튜닝 : I/O 효율화, DB Call 최소화, SQL 파싱 최소화 등
2. DB 설계 : 논리적 데이터 구조 설계, 물리적 저장 구조 설계 등
3. 인스턴스 튜닝 : Lock/Latch 모니터링 및 해소, 메모리 설정, 프로세스 설정 등

### 튜닝 전문가가 되려면 공부해야 하는 것

DBA - DB에 대한 연구 (백업/복구, 오브젝트 생성/변경, 보안 등)

SQL 튜닝 - SQL 중심의 공부 (실행계획 원리/분석/제어/유도, SQL 인터페이스, 인덱스 설계, 통계정보 수집정책)
