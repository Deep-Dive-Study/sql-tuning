# 6장 DML 튜닝

## 6.1 기본 DML 튜닝
- 지금까지 배운 인덱스와 조인 튜닝을 DML 문에도 그대로 적용이 가능함
- 다만, DML 성능에 영향을 주는 다른 요소와 튜닝 방법도 따로 있음

### 6.1.1 DML 성능에 영향을 미치는 요소
- DML 성능에 영향을 미치는 요소
  - 인덱스
  - 무결성 제약
  - 조건절
  - 서브쿼리
  - Redo 로깅
  - Undo 로깅
  - Lock
  - 커밋 

#### 인덱스
- 인덱스가 늘어나면 Wirte(Insert, Update, Delete) 작업 시 부하가 늘어남
  - 특히 Update 시에는 변경과 인덱스 수조 내에서 정렬을 다시해야 하는 이중적인 부하가 발생함

    ![Google Chrome 2024-09-28 02 20 13](https://github.com/user-attachments/assets/dcca53aa-83e0-4414-b471-bd532d0d0a85)

    ![Google Chrome 2024-09-28 02 20 31](https://github.com/user-attachments/assets/00fa08c5-1bdf-48d6-ba42-ea2ad9b8012c)

- 불필요한 인덱스는 제거하자.
  - 100만 건 삽입시 8배 차이 

#### 무결성 제약
- DB 에는 논리적으로 의미 있는 자료만 저장되게 하는 데이터 무결성 규칙이 있음
  - 개체 무결성
  - 참조 무결성
  - 도메인 무결성
  - 사용자 정의 무결성 

- 이러한 규칙은 어플리케이션으로 구현 가능하지만, DBMS에서 PK, FK, Check, Not Null 같은 제약(Constraint)을 설정하면 더 완벽하게 데이터 무결성을 지킬 수 있음
- 무결성 제약 중 PK/FK 제약은 Check / Not Null 보다 성능에 더 큰 영향을 줌
  - 해당 제약은 실제 데이터를 조회해봐야 알기 때문 

- 예시 테스트 결과

  ![Goodnotes 2024-09-28 02 24 02](https://github.com/user-attachments/assets/154dc939-90de-49eb-a37b-32b8106af39e)

#### 조건절
- SELCT 문과 실행 계획이 다르지 않기 때문에, 이들 DML 문에는 2, 3장에서 학습한 인덱스 튜닝 원리를 그대로 적용 가능

  ![CleanShot 2024-09-28 at 02 25 23](https://github.com/user-attachments/assets/b704aec1-2a48-4bf6-b43d-c59d5d234149)

#### 서브쿼리
- 이또한, SELCT 문과 실행 계획이 다르지 않기 때문에, 이들 DML 문에는 4장에서 학습한 조인 튜닝 원리를 그대로 적용 가능(서브쿼리 조인 - 4장 4절)

  ![CleanShot 2024-09-28 at 02 25 44](https://github.com/user-attachments/assets/0c1ac8d6-cd49-48a3-9bf4-7e697b07848b)

#### Redo 로깅
- 오라클은 데이터 파일과 컨트롤 파일에 가해지는 모든 변경 사항을 Redo 로그에 기록함
  - 트랜잭션 데이터가 유실된 경우, 트랜잭션을 재현하여 유실 이전 상태로 복구하는데 사용됨
- DML 수행 시마다 Redo 로그 생성해야하기 때문에 DML에 성능에 영향을 끼침
  - INSERT 작업에 대해 Redo 로깅 생략 기능을 제공하는 이유 

#### Undo 로깅
- Redo와 반대로 Undo는 트랜잭션을 롤백함으로써 현재를 과거 상태로 되돌리는데 사용

  ![CleanShot 2024-09-28 at 02 30 08](https://github.com/user-attachments/assets/cd30be0f-b5a6-4996-a218-d477d7a7cf06)

- DML 수행 시마다 Undo 로그 생성하기 때문에 DML에 성능에 영향을 끼침
  - Undo를 생략하는 기능은 제공하지 않음(반드시 생성이 필요함)
  - 책에 상세한 내용이 나오기 때문에 참고하기 바람(MVCC, 등)

#### Lock
- Lock을 필요 이상으로 자주, 길게 사용하거나 레벨을 높일 수록 DML 성능은 느려짐
  - 즉, 성능과 데이터품질은 트레이드오프 관계

#### 커밋
- DML을 끝내려면 커밋까지 완료해야함으로 서로 밀접한 관련이 있음
  - 특히 DML이 Lock에 의해 블록킹(Blocking) 된 경우, 커밋은 성능과 직결됨

- 커밋은 결코 가벼운 작업이 아님(DBMS에서 Fast Commit을 구현하여 빠르게 처리될뿐)

- 트랜잭션 저장 과정

  ![CleanShot 2024-09-28 at 02 36 44](https://github.com/user-attachments/assets/528d331e-1a8d-4395-9e46-ade7c62181a2)
 
- DB 버퍼캐시
  - 서버 프로세스(DBWR)는 버퍼캐시를 통해 데이터를 일괄 처리한다
- Redo 로그버퍼
  - Redo 성능을 위해 Redo 파일 중간에 버퍼 위치(LGWR)
- 트랜잭션 데이터 저장 과정
  - DML 문을 실행하면 Redo 로그버퍼에 변경사항 기록
  - 버퍼블록에서 데이터 변경
  - 커밋
  - Redo 로그버퍼 파일에 일괄 저장
  - 버퍼블록을 데이터파일에 일괄 저장
- 커밋
  - 커밋을 오래동안 안하는 것도 안좋지만 너무 자주하는 것도 IO를 발생시키기 때문에 좋지 않다

### 데이터베이스 Call과 성능
- SQL Call 세 단계
  - Parse call: SQL 파싱과 최적화 수행하는 단계
  - Execute call: SQL 실행하는 단계
  - Fetch call: 데이터를 읽어서 사용자에게 결과집합 전송 과정(전송할 데이터가 많은 경우 여러번의 call 발생)

    ![CleanShot 2024-09-28 at 02 39 15](https://github.com/user-attachments/assets/87630aa9-d8e0-4a41-a5ec-c782be78b036)

- 발생 시점에 따른 Call 분류
  - User call: DBMS 외부로부터 인입되는 call(WAS)
  - Recursive call: DBMS 내부에서 발생하는 call(함수/프로시저/트리거, 등)

   ![CleanShot 2024-09-28 at 02 40 30](https://github.com/user-attachments/assets/7607d210-ec44-4162-82e9-9d51a2fe8dee)

  - User call 이든 Recursive call이든 SQL을 실행할때 위의 3단계의 call을 거침
  - call이 많은 경우 성능에 안좋음. 특히 네트워크를 경유하는 User Call이 성능에 미치는 영향은 매우 큼

- 절차적 루프 처리
  - 절차적으로 반복되는 call일 경우 그나마 recursive 콜일 경우는 나음
  - user call은 느려질 수밖에 없음
  - call 한번 당 커밋을 하게되면 성능이 훨씬 느려짐(너무 오래 커밋을 안하는 것도 문제지만 너무 자주해도 안 좋음)

- One SQL의 중요성
  - 로직이 복잡하지 않으면 되도록 하나의 SQL로 끝나는 게 성능에 좋음
  - One SQL 구현시 유용한 구문 활용법
    - Insert Into Select
    - 수정 가능 조인 뷰
    - Merge 문

### 6.1.3 Array Processing 활용
- 복잡한 업무 로직을 One SQL로 구현하는 것은 어려움, 이럴 때 Array Processing을 활용하면 One SQL로 구현하지 않고도 Call 부하를 획기적으로 줄일 수 있음

 ![CleanShot 2024-09-28 at 02 48 01](https://github.com/user-attachments/assets/d5ee112b-b2c4-4539-8f5e-b81dfb6466e0)
 
 ![CleanShot 2024-09-28 at 02 48 19](https://github.com/user-attachments/assets/33a4cd75-1f72-477e-93a5-05297e17ca97)

### 6.1.4 인덱스 및 제약 해제를 통한 대량 DML 튜닝
- 동시 트랜잭션이 없는 배치 환경에서는 PK 및 인덱스 제약을 해제를 통하여 성능을 향상 시킬 수 있음

### 6.1.5 수정가능 조인 뷰
- 다른 테이블과 조인이 필요할 때 전통적인 UPDATE 문을 사용하면 비효율을 완전히 해소할 수 없음
- 인라인 뷰가 포함된 update 쿼리문은 튜닝을 통하여 속도 향상이 가능함

### 6.1.6 Merge 문 활용
- DW(데이터 웨어하우스)에서는 두 시스템 간 데이터 동기화가 가장 흔히 발생하는 작업
- 이때 오라클9i에서 도입된 MERGE 문을 활용할 수 있음(DW 시스템으로 적재 - Loading)

## 6.2 Direct Path I/O
- 온라인 트랜잭션(OLTP)은 기준성 데이터, 특정 고객, 특정 상품, 최근 거래 등을 반복적으로 읽는 경우가 많기 때문에 버퍼 캐시가 성능 향상에 도움이됨.
- 반면에, **정보계 시스템(DW/OLAP)이나 배치 작업에서는 버퍼캐시 경유하지 않는 것이 성능이 더 좋을 수 있음**
  - 대량의 데이터를 처리하기 때문에 버퍼 캐시를 경유하는 I/O 메커니즘이 역효과를 줌
- 그래서 오라클은 버퍼 캐시를 경유하지 않고 바로 데이터 블록을 읽고 쓰는 기능을 제공함. 이를, **`Direct Path I/O`** 라고 함

### 6.2.1 Direct Path I/O
- 일반적인 블록 I/O는 버퍼 캐시를 경유해서 데이터를 처리함(변경시에도) 
- 자주 읽는 블록에 대한 반복적인 I/O Call을 줄여주기 때문에 일반적인 경우에는 성능에 도움이 됨
- 다만, 대량의 데이터를 읽고 쓸 때 건마다 버퍼 캐시를 탐색한다면 개별 프로그램 성능에는 오히려 성능 저하의 원인이됨
  - 대량 블록을 건건이 디스크로부터 버퍼 캐시에 적재하고 나서 읽어야 하는 부담도 큼
  - 또한, 적재한 블록을 재사용할 가능성 또한 낮은 편, 이러한 데이터가 버퍼 캐시를 점유하면 다른 프로그램 성능에도 나쁜 영향을 줌 

- 오라클에서는 이러한 경우에 버퍼 캐시를 경유하지 않고 곧바로 데이터 블록을 읽고 쓸 수 있는 **`Direct Path I/O`** 기능을 제공함

- 아래 경우에 사용함

1. 병렬 쿼리로 Full Scan울 수행 할 때
2. 병렬 DML을 수행할 때
3. Direct Path Insert를 수행할 떄
4. Temp 세그먼트 블록들을 읽고 쓸 때
5. direct 옵션을 지정하고 export를 수행할 때
6. nocache 옵션을 지정한 LOB 컬럼을 읽을 때

### 6.2.2 Direct Path Insert
- 일반적인 INSERT가 느린 이유(동작 방식)
  - 데이터를 입력할 수 있는 블록을 Freelist에서 찾는다.
    - 테이블 HMW(High-WaterMark) 아래쪽에 있는 블록 중 데이터 입력이 가능한(여유 공간이 있는) 블록을 목록으로 관리하는데, 이를 Freelist 라고함
  - Freelist에서 할당 받은 블록을 버퍼캐시에 적재한다.
  - 버퍼캐시에 없으면, 데이터 파일에서 읽어 버퍼캐시에 적재한다.
  - INSERT 내용을 Undo 세그먼트에 기록한다.
  - INSERT 내용을 Redo 로그에 기록한다.

- Direct Path Insert 방식을 사용하는 경우 대량 데이터를 일반적인 INSERT 보다 빠르게 입력이 가능함
  - **`입력 방법`**
    - INSERT ... SELECT 문에 append 힌트 사용
    - parallel 힌트를 이용해 병렬 모드로 INSERT
    - direct 옵션을 지정하고 SQL*Loder(sqlldr)로 데이터 적재
    - CATS(create table ... as select) 문 수행
 
  - **`빠른 이유`**
    - Freelist를 참조하지 않고 HWM 바깥 영역에 데이터를 순차적으로 입력한다.
    - 블록을 버퍼캐시에서 탐색하지 않는다.
    - 버퍼캐시에 적재하지 않고, 데이터파일에 직접 기록한다.
    - Undo 로깅을 안한다.
    - Redo 로깅을 안하게 할 수 있다.

- Direct Path Insert 방식을 사용할 때 주의할 점
  - **`성능은 빨라지지만 Exclusive 모드 TM Lock이 걸린다.`**
    - 따라서, 커밋하기 전까지 다른 트랜잭션은 해당 테이블에 DML을 수행하지 못함(트랜잭션이 빈번한 주간 운영 중에는 사용X)
    - Lock 에 대해서는 DML 테이블 Lock 부분에서 다시 설명
 
  - **`Freelist를 참조하지 않고 HWM 바깥 영역에 입력하므로 테이블에 여유 공간이 있어도 재활용하지 않는다.`**
    - 따라서, 이 방식으로만 계속 INSERT하는 테이블은 사이즈가 줄지 않고 계속 늘어만 가기 때문에 주의 필요
    - Range 파티션 테이블이면 과거 데이터를 삭제할때 DELETE 대신 DROP 방식으로 지워야 공간 반환이 제대로 이루어짐(일반 INSERT를 사용하더라도)
    - 비 파티션 테이블이면 주기적으로 Reorg 작업을 수행해주어야함 

### 6.2.3 병렬 DML
- INSERT의 경우에는 append 힌트를 통해 Direct Path Write 방식으로 유도가 가능
- 반면에, UPDATE, DELETE 는 기본적으로 Direct Path Write가 불가능하기 때문에 병렬 DML 로 유도해야함
  - 병렬 처리는 대용량 데이터가 전제이므로 오라클은 병렬 DML에 항상 Direct Path Write 방식을 사용함
 
- DML을 병렬로 처리하려면, 병렬 DML 기능을 활성화 해야함
  - 힌트에는 기술하고, 병렬 DML 기능을 비활성화 한 경우는 대상 레코드를 찾는 작업은 병렬로 진행하지만, 추가/변경/삭제는 QC가 혼자 담당하므로 병목이 생김
    - QC란, Query Coordinator 의 줄임말로, 최초 DB 접속해서 SQL을 수행한 프로세스  

  ```sql
  
  alter session enable parallel dml;

  ```

  ![CleanShot 2024-09-28 at 01 59 12](https://github.com/user-attachments/assets/ecaac8ab-f735-457b-9a83-afa361244f6d)

- 병렬 INSERT는 append 힌트를 지정하지 않더라도 Direct Path Insert 방식을 사용함
  - 하지만, 병렬 DML이 작동하지 않을 경우를 대비하여 아래와 같이 append 힌트를 같이 사용하는게 좋음(혹시 모를 사태에도 일정 성능 보장 가능) 

    ![CleanShot 2024-09-28 at 02 13 30](https://github.com/user-attachments/assets/2c1c533b-5ca4-45bd-b686-63609df15229)
 
- 오라클 12c부터는 enable_parallel_dml 힌트도 지원함

  ![CleanShot 2024-09-28 at 02 14 13](https://github.com/user-attachments/assets/78c8b7b9-ca05-420c-8f38-1ec02907dc82)

- 다만, **`병렬 DML도 Exclusive 모드 TM Lock이 걸리기 때문에 주의가 필요함`**

- 병렬 DML이 잘 실행되는지 실행 계획을 통해 확인 가능함
  - 정상 작동 중

    ![CleanShot 2024-09-28 at 02 00 49](https://github.com/user-attachments/assets/ab74468d-10d0-4bb1-acd0-35a3bac7e8c4)

  - 비정상 작동(병렬 처리X - QC 처리)
    
    ![CleanShot 2024-09-28 at 02 01 12](https://github.com/user-attachments/assets/1144b9c5-73ac-47ae-8522-ea04c004b6aa)


## 6.3 파티션을 활용한 DML 튜닝
- 파티션을 이용하면 대량 추가/변경/삭제 작업을 빠르게 처리할 수 있음
  - ILM 작업을 빠르고 부담없이 할 수 있음 

### 6.3.1 테이블 파티션
- 파티셔닝은 **`테이블 또는 인덱스를 파티션 키(특정 컬럼 값)에 따라 별도 세그먼트에 나눠서 저장하는 것`** 을 말함
  - 논리적으로는 하나의 테이블이지만 실제로 물리적으로는 여러 개의 테이블의 효과를 가짐

    ![Google Chrome 2024-10-06 01 38 49](https://github.com/user-attachments/assets/4984bbd9-23e4-4e8b-9161-19e766d61d4e)

- **`파티션이 필요한 이유`**
  - `관리적 측면` : 파티션 단위의 작업(백업, 추가, 삭제, 변경)→ 가용성 향상
    - 같은 테이블이라도 서로 다른 파티션에 영향을 미치지 않음
  - `성능적 측면` : 파티션 단위의 조회 및 DML, 경합 또는 부하 분산

- **`파티션 테이블의 성능 향상 원리`**
  - 파티션 Pruning을 통해 SQL 파싱이나 실행 시점에 조건절을 분석하여 **`다른 파티션 세그먼트를 액세스 대상에서 제외`** 하는 것에 있음
  - 예를 들어, 파티션이 적용되지 않은 테이블에 1000만건의 데이터가 있다면 1000만 건 중에 조건에 따른 데이터를 필터링을 함
  - 반면에, 파티션이 적용된 경우에는 1000만 건 중 파티션닝이 된 테이블만 액세스 하여 필터링 하기 때문에 성능상 이점이 생김

- **`파티션 종류`**
  - Range, 해시, 리스트
  - Range : 날짜 컬럼을 기준으로 파티셔닝하는 방식
  - 해시 : 파티션 키 값을 해시 함수에 입력해서 반환받은 값이 같은 데이터를 같은 세그먼트에 저장하는 방식
    - 등치 조건 또는 IN-List 조건으로 검색할 때만 파티션 Prunning이 동작함  
  - 리스트 : 사용자가 정의한 그룹핑 기준에 따라 데이터를 분할하는 방식
    - 가능하면 각 파티션에 값이 고르게 분산되도록 해야함   

- Range 스캔 예시

  ![Google Chrome 2024-10-06 01 42 47](https://github.com/user-attachments/assets/d51d7859-11fb-4206-9eb0-6d833ea2cb3a)

  - 조회시에도 검색 조건을 만족하는 파티션만 가져오기 때문에 Full Scan시에 더욱 효과적임
  - 보관주기 정책에 따라 과거 데이터를 저장한 파티션만 따로 백업/삭제 하는 데이터 관리 작업을 효율적이고 빠르게 수행 가능함 
  - Range 파티셔닝은 특히 애매한 사이즈(20% ~ 40%)의 데이터를 가져오는 상황에 더욱 효과적임
    - 인덱스 or Full Scan 둘다 부담스러운 경우

      ![CleanShot 2024-10-06 at 01 46 05](https://github.com/user-attachments/assets/ead1d536-a85d-4247-9c34-a4f5e8fe033f)

### 6.3.2 인데스 파티션
- **`파티션 분류`**
  - 테이블 파티션
  - 인덱스 파티션
    - 각 파티션이 커버하는 테이블 파티션 범위에 따라 분류 가능 
    - 로컬 파티션 인덱스
    - 글로벌 파티션 인덱스 

![Goodnotes 2024-10-06 01 57 29](https://github.com/user-attachments/assets/c1532949-3d4f-489c-82e9-545ce299f7de)

#### 로컬 파티션 인덱스
- **`각 테이블 파티션과 1:1로 대응 되는 인덱스 파티션`**

  ![Google Chrome 2024-10-06 01 59 14](https://github.com/user-attachments/assets/63c62ad3-060c-4a9d-a733-8d637a868cf8)

  ![Google Chrome 2024-10-06 02 00 55](https://github.com/user-attachments/assets/8d1aa56c-509d-4034-a0c5-06999ed141df)

- 인덱스 파티션은 테이블 파티션의 속성을 그대로 상속 받기 때문에 테이블 파티션 키는 인덱스 파티션 키가 됨
- 파티션 테이블이 변경 되면 로컬 파티션 인덱스도 이에 맞추어 오라클이 자동으로 변경해 줌(관리의 편의성)

#### 글로벌 파티션 인덱스
- **`파티션을 테이블과 다르게 구성한 인덱스`**
  - 파티션 유형이 다르거나, 파티션 키가 다르거나, 파티션 기준값 정의가 다른 경우
  - 로컬 인덱스가 아니면 모두 글로벌 파티션 인덱스임
- 테이블 파티션 구성을 변경하는 경우 Unusable 상태로 바뀌므로 재생성해주어야 함

  ![Google Chrome 2024-10-06 02 02 02](https://github.com/user-attachments/assets/18a92f9b-b02f-41b3-9494-85d81ea8b463)

#### 비파티션 인덱스
- **`별도로 파티셔닝 되지 않은 인덱스`**
- 비파티션 인덱스와 파티션 테이블과 조합될 때, 테이블에 변경이 있으면 인덱스를 재생성해야 함

  ![Google Chrome 2024-10-06 02 03 49](https://github.com/user-attachments/assets/9295b273-999c-4b04-9893-e809254f4a0c)

#### 인덱스 파티션 제약
- **`Unique 인덱스를 파티셔닝하려면, 파티션 키가 모두 인덱스 구성 컬럼이어야 한다.`**
- 왜냐하면, 인덱스의 Unique 조건을 확인하기 위해 모든 파티션을 검사해야함
- 그렇게 되면, 파티션을 적용하는 의미가 사라짐

### 6.3.3 파티션을 활용한 대량 UPDATE 튜닝
- 대량의 Update 작업은 부담이 되는 작업
  - 전체 데이터의 5% 이상인 경우, 인덱스를 제거하고 한 후에 작업하는 것이 이득임
  - 다만, 실무에서는 인덱스를 수정하는 것에 대한 부담이 크기 때문에 오래걸리더라도 그냥 하는 경우가 많음
  - 이러한 상황에 파티션이 적용되어 있다면 좋은 해법(파티션 Exchange)이 존재함
 
#### 파티션 Exchange를 이용한 대량 데이터 변경
  - 수정된 값을 갖는 임시 세그먼트를 만들어 원본 파티션과 바꿔치기하는 방식

  ![Goodnotes 2024-10-06 02 15 41](https://github.com/user-attachments/assets/2e66b796-396d-437c-ae48-7c02c981c532)

  - 먼저 임시 테이블을 만들고
  - 임시 테이블에 update 될 데이터를 insert
  - 임시 테이블에 인덱스를 생성
  - 기존 파티션 테이블과 임시 테이블을 exchange
  - 임시 테이블 drop
 
### 6.3.4 파티션을 활용한 대량 DELETE 튜닝
- update 작업은 변경 대상 컬럼을 포함하는 인덱스만 재생성하면 되지만, delete 작업은 모든 인덱스를 재생성 해야 하기 때문에 인덱스 재생성에 대한 비용 부담이 더 큼
- 파티션 drop을 이용하면 대량 데이터도 쉽게 삭제가 가능함
- 일부만 삭제해야하는 경우에는 일부를 삭제하기 보다 파타션 truncate을 통해 전체 삭제한 후에 삭제하지 않을 데이터를 다시 만드는 방식이 오히려 유리함

- 서비스 중단 없이 파티션을 Drop 혹은 Truncate 하려면 아래 조건을 만족해야함
  - 파티션 키와 커팅 기준 컬럼이 일치해야함
  - 파티션 단위와 커팅 주기가 일치해야함
  - 모든 인덱스가 로컬 파티션 인덱스여야함 

### 6.3.5 파티션을 활용한 대량 INSERT 튜닝
- 파티션 테이블인 경우, 인덱스를 파티션 별로 재생성 가능하기 때문에 insert 전에 제거한 후에 추가하면 됨 

  ![Goodnotes 2024-10-06 02 22 58](https://github.com/user-attachments/assets/77b94c76-c7e2-4dc7-a7ac-cee441dba0a5)


## 6.4 Lock과 트랜잭션 동시성 제어
- 자신/회사에서 사용하는 데이터베이스의 Lock 매커니즘과 트랜잭션 동시성 제어에 대한 학습은 필수적임
  - Lock은 데이터베이스의 특징을 결정짓는 가장 핵심적인 메커니즘
  - 고유한 Lock 메커니즘을 이해하지 못하면 고품질, 고성능 애플리케이션을 구축하기 어려움 

### 6.4.1 오라클 Lock
- 오라클은 공유 리소스와 사용자 데이터를 보호할 목적 아래와 같은 Lock을 사용함
  - **`DML Lock`**
    - 어플리케이션 개발 측면에서 가장 중요하게 다뤄야 할 Lock
    - 다중 트랜잭션이 동시에 액세스하는 사용자 데이터의 무결성을 보호해줌
    - DML Lock엔 `테이블 Lock`과 `로우 Lock`이 존재함
 - **`DDL Lock`**
 - **`래치`**
   - SGA에 공유된 각종 자료구조를 보호하기 위해 사용함
 - **`버퍼 Lock`**
   - 버퍼 블록에 대한 엑세스를 직렬화하기 위해 사용함
 - **`라이브러리 캐시 Lock/Pin`**
   - 라이브러리 캐시에 공유된 SQL 커서와 PL/SQL 프로그램을 보호하기 위해 사용함

#### DML 로우 Lock
- **`두 개의 동시 트랜잭션이 같은 로우(행)를 변경하는 것을 방지함`**
  - 하나의 로우를 변경하려면 로우 Lock을 먼저 설정해야함 
- 같은 로우를 UPDATE/DELETE/INSERT를 시도할때
  - UPDATE, DELETE : 진행중인(아직 커밋하지 않은) 로우를 다른 트랜잭션이 수정할 수 없음(배타적 모드)
  - INSERT : Unique 인덱스가 있는 경우에는 같은 값을 입력하려고 할때 블로킹(락 경합)이 발생함
    - 선행 트랜잭션이 커밋할 동안 후행 트랜잭션은 기다림
    - 선행 트랜잭션이 커밋하면 후행 트랜잭션은 실패하고, 선행 트랜잭션이 롤백하면 후행 트랜잭션은 성공함
- DML 로우 Lock에 의한 성능 저하를 방지하려면 Lock을 너무 오래 유지하지 않도록 커밋 시점을 조절해야 함
  - Lock이 오래 지속되지 않도록 SQL을 튜닝해야함 

- MVCC 모델을 사용하는 오라클은 (for update절이 없는) SELECT 문에는 로우 Lock을 사용하지 않음
  - 즉, DML과 SELECT는 서로의 진행을 방해하지 않음
- MVCC 모델을 사용하지 않는 DBMS의 경우에는 SELECT 문에 공유 Lock을 사용함(같은 SELECT만 가능)
  - 해당 경우에는, DML과 SELECT가 서로의 진행을 방해할 수 있음
    - 다른 트랜잭션이 읽고 있는 로우를 변경하려면 다음 레코드로 이동할 때까지 기다려야함(변경 중인 경우에는 커밋할때까지) 

#### MVCC 요약 정리
- 다른 트랜잭션이 변경한 로우를 읽을 때 복사본 블록을 만들어서 쿼리가 '시작된 시점'으로 되돌려서 읽는 방식
- 변경이 진행중인(아직 커밋하지 않은) 로우를 읽을 때도 Lock이 풀릴 때까지 기다리지 않고 복사본을 만들어서 읽음
- 따라서, SELECT 문에 Lock을 사용할 필요가 없음 


#### DML 테이블 Lock(= TM Lock)
- 현재 트랜잭션이 갱신 중인 테이블 구조를 다른 트랜잭션이 변경하지 못하게 하기 위한 Lock
  - 오라클은 DML 로우 Lock 이전에 테이블 Lock을 설정함

- 로우 Lock은 항상 배타적 모드(1가지 Lock 모드)만 사용하는 반면에 테이블 Lock에는 여러 Lock 모드(RS, RX, S, SRX, X)가 있음
  - Lock Mode 간 호환성

     ![Google Chrome 2024-10-06 22 23 24](https://github.com/user-attachments/assets/49ae8fac-e33b-4cad-a849-59a2a94c9772)

    - RS : row share(또는 SS : sub share)
    - RX : row exclusive(또는 SX : sub exclusive)
    - S : share
    - SRX : share row exclusive(또는 SSX : share/sub exclusive)
    - X : exclusive

  - 선행 트랜잭션과 호환되지 않는 모드로 테이블 Lock을 설정하려는 후행 트랜잭션은 대기하거나 작업을 포기해야함

- 흔히 테이블 Lock을 테이블 전체에 걸리는 Lock이라고 오해하기 쉬운데, 그게 아니라 테이블 Lock을 설정한 트랜잭션이 해당 테이블에서 어떤 작업을 수행중인지 알리는 일종의 푯말(Flag)이라고 이해하면 좋음
  - 후행 트랜잭션은 해당 푯말을 보고 기다릴지, 포기할지 결정하면 됨
    - Lock이 해제될때까지 기다리거나(default)
    - 일정 시간만 기다리다 포기하거나(wait)
    - 기다리지 않고 포기하거나(nowait)

- 예시
  - DDL을 이용하여 테이블 구조를 변경하려 할때
    - 테이블 구조를 변경하려는 트랜잭션은 해당 테이블에 TM Lock이 설정돼있는지 확인함
    - RX모드로 설정한 트랜잭션이 하나라도 있다면 작업을 멈춤
    - DDL이 먼저 수행중이라면 DML을 수행하려는 트랜잭션이 기다림

#### Lock을 푸는 열쇠, 커밋
- 블로킹과 교착상태는 다름
  - `블로킹` : 선행 트랜잭션이 설정한 Lock 때문에 후행 트랜잭션이 기다리는 상태
  - `교착상태` : 두 트랜잭션이 각각 특정 리소스에 Lock을 설정한 상태에서 두 트랜잭션 모두 맞은편 트랜잭션의 리소스에 Lock을 설정하려고 하는 상황(무한 블로킹)
    - 오라클에서는 교착상태가 발생하면 이를 먼저 인지한 트랜잭션이 문장 수준 롤백을 진행한 후 에러 메시지를 던짐

- 커밋은 너무 자주해도 반대로 너무 자주하지 않아도 문제가 됨

### 6.4.2 트랜잭션 동시성 제어
- 트랜잭션 동시성 제어는 **`비관적 동시성 제어`** 와 **`낙관적 동시성 제어`** 로 나뉨
  - **`비관적 동시성 제어`**
    - `사용자들이 같은 데이터를 동시에 수정할 것으로 가정하고`, 한 사용자가 데이터를 읽는 시점에 Lock을 걸고 조회/갱신이 완료될때까지 이를 유지함
     - `select ... for update`로 비관적 락을 걸 수 있음
     - 동시성을 심각하게 떨어뜨릴 우려가 있지만, `for update wait ...`, `for update nowait` 옵션으로 동시성을 증가시킬 수 있음
  - **`낙관적 동시성 제어`**
     - `사용자들이 같은 데이터를 동시에 수정하지 않을 것으로 가정하고`, 데이터를 읽을때 Lock을 설정하지 않는다. 읽는 시점에 변경된 데이터인지 반드시 검사해야 함
     - 모든 컬럼에 대해 변경이 됐는지 확인하거나, 수정시간에 대한 컬럼을 따로 만들어서 수정시간이 변경됐는지 확인함

- 동시 요청이 자주 발생하여 충돌이 잦은 경우에는 오히려 비관적 동시성 제어가 효율적이고 성능이 빠름

#### 데이터 품질과 동시성 향상을 위한 제언
- 비관적 동시성 제어(Lock/for update) 사용을 두려워하지 말아야 함
- Lock이 필요한 상황이면 정확히 사용하고, 번거롭더라도 wait 또는 nowait 옵션을 활용하여 예외처리에 주의를 기울어야 함
- 불필요하게 Lock을 오래 유지하지 않고, 트랜잭션의 원자성을 보장하는 범위 내에서 가급적 빨리 커밋해야 함
- 비관적 동시성 제어와 낙관적 동시성 제어를 같이 사용하는 방법도 있음
- 동시성을 향상하고자 할때는 먼저 SQL 튜닝을 완벽히 하고 나서 해도 늦지 않음(성능 < 데이터 품질)

### 6.4.3 채번 방식에 따른 INSERT 성능 비교
- INSERT/UPDATE/DELETE 중 가장 중요하고, 튜닝의 요소가 많은 것은 INSERT 작업임
  - 수행빈도가 높으며, 채번 방식에 따라 성능 차이가 많이 나기 때문임
    - 채번 : 새로운 번호를 딴다/번호를 매긴다
      - 각 레코드를 식별하려면 유니크한 값(PK)이 필요한데 그러한 고유한 값을 생성하는 작업  

- **`채번 방식 종류`**
  - 채번 테이블
  - 시퀀스 오브젝트
  - MAX + 1 조회 

#### 채번 테이블
- 채번하기 위한 별도의 테이블을 관리하는 방식
  - 채번 레코드를 읽어서 1을 더한 값으로 변경하고, 그 값을 새로운 레코드를 입력하는데 사용함
  - 두 트랜잭션이 중복 값을 채번할 가능성을 원천적으로 방지함

- `장점`
  - 범용성이 좋음
  - 중복 레코드 발생에 대비하지 않아도 됨
  - INSERT 과정에 결번을 방지할 수 있음
  - PK가 복합컬럼일때도 사용할 수 있음

- `단점`
  - 채번 레코드를 변경하기 위한 로우 Lock 경합 때문에 성능이 안좋음
  - 따라서, 동시 INSERT가 아주 많은 테이블에는 사용하기 어려움

    ![CleanShot 2024-10-06 at 22 44 37](https://github.com/user-attachments/assets/187e16a1-43f6-4044-8eda-dc40087beb14)


#### 시퀀스 오브젝트
- 오라클 내부에서 관리하는 채번 테이블

- `장점`
  - 성능이 빠름
  - 중복 레코드 발생에 대비하지 않아도 됨

- `단점`
  - 테이블 별로 시퀀스 오브젝트를 생성하고 관리하는 부담이 있음
  - 시퀀스 채번 과정에서 Lock에 의한 성능 이슈가 있음 (단, 캐시 사이즈를 적절히 설정하면 빠른 성능을 제공한다)
  - PK가 단일 컬럼일 때만 사용할 수 있음
  - 결번이 생길 수 있음

    ![CleanShot 2024-10-06 at 22 46 37](https://github.com/user-attachments/assets/a3eab608-06d8-45ae-818c-f5a518f9dff7)


#### MAX + 1 조회
- 대상 테이블의 최종 일련번호를 조회하고, 거기에 1을 더해서 INSERT하는 방식

  ![CleanShot 2024-10-06 at 22 48 08](https://github.com/user-attachments/assets/81f5cb43-62d2-4349-9659-287873e3e5af)

  - `select max(거래일련번호) + 1 from 거래`의 값을 새로 insert할 row의 pk로 사용

- `장점`
  - 시퀀스나 채번 테이블을 관리하지 않아도 됨
  - 동시 트랜잭션에 의한 충돌이 많지 않으면 성능이 매우 좋음
  - PK가 복합컬럼이어도 사용할 수 있음

- `단점`
  - 레코드 중복에 대비한 세밀한 예외처리가 필요함
  - 다중 트랜잭션에 의한 동시 채번이 심하면 시퀀스보다 성능이 많이 나빠질 수 있음
  - MAX 값 조회에 최적화된 인덱스를 구성하지 않는 경우에 성능 이슈가 발생할 수 있음

- **`각 채번 방식에 발생하는 Lock 경합 요소 정리`**

  ![Goodnotes 2024-10-06 22 50 18](https://github.com/user-attachments/assets/b5e12fd2-8cf4-4712-ba16-d393d715073b)

- **`Lock 경합 요소를 고려한 채번 방식 선택 기준 정리`**

  ![Goodnotes 2024-10-06 22 51 45](https://github.com/user-attachments/assets/fd48ebf1-c89b-4318-aabc-d5cfc412d782)


#### 시퀀스보다 좋은 솔루션
- 한 개 이상의 구분 속성과 함께 뒤쪽에 순번 대신 입력일시를 두는 방식

#### 인덱스 블록 경합
- INSERT 성능이 너무 빨라도 인덱스를 추가하는 과정에서 인덱스 경합이 발생할 수 있음

  ![Google Chrome 2024-10-06 22 53 44](https://github.com/user-attachments/assets/c798a648-d6c6-4092-80a3-f4e29a74d94c)

  - 이러한 특징을 갖는 인덱스를 `Right Growing 인덱스` 라고 함

- 가장 일반적인 해소 방법은 인덱스를 해시 파티셔닝하는 것
  - 혹은 인덱스를 리버스 키 인덱스로 전환하는 방법도 고려할 수 있음 
