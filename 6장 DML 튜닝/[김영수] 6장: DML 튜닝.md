# 6장. DML 튜닝

## 6.1 기본 DML 튜닝

### 6.1.1 DML 성능에 영향을 미치는 요소

* 인덱스
* 제약조건
* 조건절
* 서브쿼리
* Redo, Undo 로깅
* Lock
* 커밋

#### 인덱스와 DML 성능

INSERT시 인덱스가 들어갈 블록을 찾아 넣어야 하므로 부하가 걸린다.

DELETE시 인덱스 레코드를 찾아서 삭제해줘야 한다

UPDATE 할 때는 변경된 컬럼을 참조하는 인덱스만 찾아 변경해주면 된다. 

테이블에서 한 건 변경할 때마다 인덱스에서는 2개의 오퍼레이션이 발생한다. 



즉 인덱스 개수가 DML성능에 영향을 매우 미치므로, 인덱스 하나라도 줄이면 TPS는 그만큼 향상된다

#### 무결성 제약조건과 DML 성능

* 참조, 도메인 무결성 - PK, FK, Check, NotNULL 
  * check는 age >= 10 같은 그냥 사용자 정의 무결성 제약조건임

PK, FK제약은 Check, Not null 제약조건보다 성능에 더 큰 영향을 미친다.

Check, NotNull은 정의한 제약 조건을 준수하는지만 확인하면 되지만, PK, FK 제약은 실제 데이터를 조회 해봐야 하기 때문이다.

#### Redo 로깅과 DML 성능

오라클은 파일에 가해지는 모든 변경사항을 Redo 로그에 기록한다. 

* Redo 로그는 트랜잭션데이터가 유실됐을 떄 트랜잭션을 재현함으로써 복구하는데 사용됌

INSERT 작업에 대해 Redo 로깅 생략 기능을 제공하며, 생략하면 성능은 빨라지지만 복구에는 사용할 수 없다.

#### Undo 로깅과 DML 성능

Redo는 과거를 현재상태로 복구하는데 사용하고, Undo는 트랜잭션을 롤백하는데 사용하여 현재를 과거 상태로 되돌리는데 사용된다.

DML을 수행할때마다 Undo를 생성하므로 성능에 영향을 미치지만, 이 Undo를 안남길수는 없고 방법도 제공하지 않는다

#### Lock과 DML 성능

Lock을 필요 이상으로 자주, 길게 사용하면 DML 성능은 당연히 느려진다.



또한 커밋도 성능에 영향을 미치는데, 프로세스가 했던 작업을 디스크에 기록하라는 명령어인 셈이므로, 저장 완료할때까지 다음 작업을 진행할 수 없다. Redo 로그에 기록된 내용을 디스크에 기록하도록 신호 보낸 후 작업을 완료했다는 신호를 받아야 진행할 수 있다. Sync(동기)방식인것이다. 그래서 커밋은 생각보다 느리고, 루프 돌면서 커밋하는것보다 모아서 커밋하는것이 좋다.

### 6.1.2 데이터베이스 Call과 성능 - 한방 SQL의 중요성

SQL은 아래 3단계로 나누어 실행됌

- ﻿﻿Parse Call : SQL 파싱과 최적화를 수행하는 단계다. SQL과 실행계획을 라이브러 리 캐시에서 찾으면, 최적화 단계는 생략할 수 있다.
- ﻿﻿Execute Call : 말 그대로 SQL을 실행하는 단계다. DMIL은 이 단계에서 모든 과정 이 끝나지만, SBLECT 문은 Fetch 단계를 거친다.
- ﻿﻿Fetch Call : 데이터를 읽어서 사용자에게 결과집합을 전송하는 과정으로 SELECT
    문에서만 나타난다. 전송할 데이터가 많을 때는 Fetch Call이 여러 번 발생한다.

![image-20240915143606595](./images//image-20240915143606595.png)

CALL이 어디서 발생하느냐에 따라 User Call과 Recusive Call로 나뉨



User Call : 네트워크를 통해 외부로부터 인입되는 CALL. WAS에서 발생하는 CALL이라고도 할수있다.

Recusive Call : DBMS 내부에서 발생하는 CALL. SQL 파싱과 최적화 과정에서 발생하는 데이터 조회, PL/SQL로 작성한 사용자 정의 함수, 프로시저, 트리거에 내장된 SQL 실행시 발생하는 CALL



즉 Call이 발생할때마다 Parse, Execute, Fetch가 발생하며 Call이 많으면 성능은 느릴수밖에 없으며, 네트워크를 경유할수록 당연히 지연시간이 붙어 더 느려진다.



예를들어 100만건 데이터를 insert하는데, 1건씩 넣는다고 하자.

당연히 네트워크를 경유하면서, 한건한건씩 커밋하니까 매우 느릴수밖에 없다. (커밋도 속도가 매우 느림)

이때 bulk로 해서 천개, 만개, 십만개씩이라도 묶어 처리하면 성능은 급격하게 상승된다

### 6.1.4 인덱스 및 제약 해제를 통한 대량 DML 튜닝

제약조건을 비활성화 하고, 인덱스도 Drop하고 대량의 데이터를 insert 하면 성능이 매우 빨라진다. 



수정가능 조인뷰와 Merge는 오라클 전용이라 생략. 

## 6.2 Direct Path I/O 활용

OLTP는 반복적으로 읽기 때문에 버퍼 캐시가 상당히 도움을 주지만 배치 프로그램등은 대량 데이터를 처리하기 때문에 버퍼 캐시를 경유하는 I/O가 성능을 떨어트릴 수 있다.

파일 캐시를 경유하지 않고 버퍼 풀에서 디스크로 직접 액세스해서 불필요한 지연(2중 캐시 처리)이 발생하지 않도록 하는 방식이 바로 Direct I/O이다.

메모리 효율적 사용: 복사 과정 감소
캐시 관리 단순화: 파일 시스템 캐시를 사용하지 않기 때문에 캐시 관리의 복잡성을 피할 수 있음

**MySQL**에서는 **InnoDB 스토리지 엔진**을 통해 **Direct I/O**를 지원한다. 아래 설정을 통해 지원할 수 있다. 

- **`innodb_flush_method` 설정**

  - **`O_DIRECT`**: 데이터 파일에 대한 I/O에서 OS의 버퍼 캐시를 우회하여 디스크에 직접 접근
  - **`O_DIRECT_NO_FSYNC`**: `O_DIRECT`와 유사하지만, 파일 동기화를 위한 `fsync()` 호출을 생략하여 성능을 더욱 향상시킨다.

- **설정 방법**

  ```
  SET GLOBAL innodb_flush_method = O_DIRECT;
  ```

  또는 `my.cnf` 설정 파일에 다음과 같이 추가

  ```
  [mysqld]
  innodb_flush_method = O_DIRECT
  ```

- **주의사항**

  - Direct I/O를 사용하면 OS의 버퍼 캐시를 우회하므로, 데이터베이스와 OS 간의 캐시 일관성이 향상되고 성능이 개선될 수 있다.
  - 그러나 디스크 및 파일 시스템의 특성에 따라 성능 이점이 달라질 수 있으므로, 테스트를 통해 확인하는 것이 좋다.



### 6.2.1 Direct Path I/O

오라클은 버퍼 캐시를 경유하지 않고 곧바로 데이터 블록을 읽고쓸수있는 Direct Path I/O 기능을 제공하며, 아래는 그 기능이 작동하는 경우다

1. ﻿﻿﻿병렬 쿼리로 Full Scan을 수행할 때
2. ﻿﻿﻿병렬 DML을 수행할 때
3. ﻿﻿﻿Direct Path Insert를 수행할 때
4. ﻿﻿﻿Temp 세그먼트 블록들을 읽고 쓸 때
5. ﻿﻿﻿direct 옵션을 지정하고 export를 수행할 때
6. ﻿﻿﻿nocache 옵션을 지정한 LOB 컬럼을 읽을 때