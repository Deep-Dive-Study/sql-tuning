# 3장 인덱스 튜닝

## 3.1 테이블 액세스 최소화

### 3.1.1 테이블 랜덤 액세스

- 테이블 랜덤 액세스가 성능에는 어느정도 영향을 줄까?

#### 인덱스에 대한 맹신 또는 섣부른 자신감
- 파티션 Prunning이 필요한 이유? 혹은 인덱스로 검색하는데도 느린 이유는 뭘까?
  - 결론부터 말하면 아무리 빠르게 데이터를 찾더라도(위치를) **`디스크에서 데이터를 가져오는 행위가 매우 느리고 비용이 많이 드는 작업`** 이기 때문에 성능에 미치는 영향이 큼

#### 인덱스 ROWID는 물리적 주소? 논리적 주소?
- SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우(커버링 인덱스)가 아니면 원하는 자료를 찾기 위해 **`인덱스를 스캔한 후에 반드시 ROWID로 테이블에 액세스 해야함`**

![CleanShot 2024-07-31 at 23 35 15](https://github.com/user-attachments/assets/ee8cfb3d-ac64-4d54-85c6-cc56cde25a88)

- 인덱스를 스캔하는 이유는 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빠르게 찾고, 거기서 테이블 레코드를 찾아가기 위한 주소값, 즉 ROWID를 얻으려는데 목적이 있음
- 인덱스의 ROWID는 포인터(물리적 주소)가 아님. **`논리적 주소에 가까움`**
  - 테이블 레코드를 찾아가기 위한 논리적 정보를 담고 있기 때문, 디스크 상에서 바로 엑세스 가능한 실제 물리적 위치를 나타내지는 않음
  - 찾아가기 위한 상대적 주소를 가지고 있을 뿐, 직접 연결된 구조는 아님
  - 따라서, **`디스크 주소 정보를 이용해 해시 알고리즘으로 버퍼 블록을 찾아가는 과정이 수반됨(버퍼 캐시 먼저 검색, 등)`**
    - 해당 과정은 캐시버퍼 체인 래치와 버퍼 Lock에 대한 경합이 발생할 수 도 있듯이 생각보다 고비용의 작업임

  - 메모리 DB의 인덱스는 포인터이기 때문에 메모리의 물리적 주소가 맞음

    ![CleanShot 2024-07-31 at 23 39 31](https://github.com/user-attachments/assets/30ec6c63-7f75-4958-ba8c-dcea9928367b)

    ![CleanShot 2024-07-31 at 23 43 41](https://github.com/user-attachments/assets/c00eee01-39b8-4d64-aa43-9173f9201910)

      - ROWID를 분해해서 DBA 정보 확인
      - 해싱 결과로 해시 체인 찾기(래치 획득)
      - 해시 체인 내부에서 버퍼 헤더 찾기(버퍼 캐시의 메모리 주소)
      - 버퍼 헤더가 있으면 포인터로 버퍼 블록 찾아가기
      - 버퍼 헤더가 없으면 디스크에서 데이터 파일 → 블록 → 레코드 찾아가서 캐시에 로딩 & 결과 리턴

- 우편과 전화의 비교를 생각하면 이해하기 쉬움

#### Table Full Scan I/O
- 테이블 세그먼트 헤더에 익스텐트 맵 확인
- 익스텐트 맵을 통해 각 익스텐트의 첫 번째 블록 DBA를 알 수 있음
- 익스텐트 내부의 블록은 연결되어 있으므로 시퀀셜하게 읽으면됨

### 3.1.2 인덱스 클러스터링 팩터
- **`특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도`**
  - 군집성 계수(Clustering Factor, CF)

- CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 좋음
  - **`인덱스 레코드 정렬 순서와 실제 테이블 정렬 순서가 비슷하기 때문에 테이블 액세스량에 비해 블록 I/O가 적게 발생함`**
    → `버퍼 Pinning` (인덱스 ROWID로 테이블 액세스 할 때, 래치 획득과 체인 스캔 후 블록에서 데이터를 읽고 포인터 그대로 유지)
      - 다음에 읽을 테이블 블록과 직전에 읽은 테이블 블록의 주소가 같기만 하면 됨

        ![CleanShot 2024-07-31 at 23 54 57](https://github.com/user-attachments/assets/7bfc9650-e279-4590-8cdd-3c84b6bcb6c4)

  - **`CF가 좋은 경우`**

    ![CleanShot 2024-07-31 at 23 52 41](https://github.com/user-attachments/assets/77f3d5db-90d3-4c54-911a-00d6996da2f2)

  - **`CF가 좋지 않은 경우`**

    ![CleanShot 2024-07-31 at 23 53 30](https://github.com/user-attachments/assets/e6a358ee-fc7d-48ab-be20-3bf30d00b9a5)

### 3.1.3 인덱스 손익분기점
- 인덱스의 ROWID로 테이블 액세스하는 것은 생각보다 **고비용 구조** 임
  → 즉, **`읽어야 할 데이터가 일정량 이상 넘어가면 테이블 풀스캔이 효과적이게 됨`**

- Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 **`인덱스 손익분기점`** 이라고 함
  - 보통 10~100만건 이내 테이블에서 손익 분기점은 5~20% 수준, BCHR, CF에 따라 달라짐 (1000만건을 넘어가면 더 낮아질 수 있음, 실제 개수에도 영향을 받음)
    - Index Range Scan은 랜덤 액세스 방식에 Single Block I/O라서 데이터를 한번에 많이 가져올 수 없음
  - Table Full Scan은 1000건을 조회하든, 1000만건을 조회하든 성능이 일정함
    → 시퀀셜 액세스, Multiblock I/O라 한번에 대량 데이터를 가져오는데 매우 유리함

  ![CleanShot 2024-08-01 at 00 18 03](https://github.com/user-attachments/assets/15a497d8-7d4d-4f81-8dc7-7a5227e97ab4)

- 이는 **`인덱스 스캔이 항상 좋은 것은 아니라는 의미`**. 그렇다고 이를 높이기 위해 어떤 조치를 취해야 하는 것은 아님
- **OLTP 프로그램과 Batch성 프로그램의 튜닝의 특징을 구분 짓는 핵심 개념 **

#### OLTP 튜닝 vs 배치 프로그램 튜닝
- **`OLTP 튜닝`**
  - 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 중요함
  - NL 조인 사용
  - 인덱스로 소트 연산 생략

- **`배치 프로그램 튜닝`**
  - 전체범위 처리 기준으로 튜닝해야함
  - 처리 대싱 집합 중 일부를 빠르게 처리하는 것이 아니라 전체를 빠르게 처리하는 것을 목표로 해야함
  - 대량 데이터를 빠르게 처리하려면 Full Scan과 해시 조인이 유리함
  - 초대용량 테이블을 Full Scan하면 오래 걸리기 때문에 배치 프로그램은 파티션 활용 전략이 매우 중요한 튜닝 요소
  - 파티션 테이블을 조회할때는 인덱스를 사용하는 것은 성능이 그다지 좋지 않음
  - 파티셔닝은 Full Scan을 빠르게 처리하기 위함
 
- 모든 성능 문제를 인덱스로 해결하려 해서는 안됨
- 인덱스는 단지 큰 테이블에서 아주 적은 일부 데이터를 빨리 찾고자 할 때 주로 사용하는 도구일 뿐

### 3.1.4 인덱스 컬럼 추가
- **테이블 액세스 최소화를 위해 가장 일반적으로 사용하는 튜닝 기법은** **`기존 인덱스에 컬럼 추가 하는 것`**
  - 다만, 실 운영 환경에서는 인덱스 구성을 변경하기 쉽지 않기 때문에 적절하게 판단해야함
 
- 인덱스를 마구 추가하는 것은 관리 비용이 증가하고, DML 부하에 따른 트랜잭션 성능 저하, 개수 제한 등의 여러 문제가 있기 때문에 함부로 추가하지 않는 것이 좋음

- **인덱스 스캔 후, 테이블 액세스 과정에서 필터되는 데이터가 많은 경우 사용**
 - **인덱스 스캔량 자체는 줄지 않지만 테이블 랜덤 액세스 횟수를 줄여줄 수 있음**

  ![CleanShot 2024-08-01 at 00 31 44](https://github.com/user-attachments/assets/66d0934f-7c46-48c2-a9d3-c8a52c5da67f)

  ![CleanShot 2024-08-01 at 00 31 12](https://github.com/user-attachments/assets/a7c34624-1009-40e7-935d-b706d5eff61d)

  - cr: Consistent Read(Consistent Read Mode로 버퍼 캐시에서 특정 블록을 읽는 것)
  - pr: Physical Read(특정 블록을 읽어서 버퍼 캐시에 로딩)

### 3.1.5 인덱스만 읽고 처리
- 테이블 랜덤 액세스가 아무리 많아도 필터 조건에 의해 버려지는 레코드가 거의 없다면 비효율적인 부분은 없는 것

- 이런한 경우에는 쿼리에 사용되는 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 아예 발생하지 않도록 하는 방법을 고려해볼 수 있음
  - 인덱스만 읽어서 처리하는 쿼리를 **`Covered 쿼리`** , 해당 쿼리에 사용된 인덱스를 **`Covered 인덱스`** 라고 함
  - 방법은 좋으나 추가해야 할 컬럼이 많은 경우에는 실제로 적용하기에는 어려움

#### Include 인덱스
- 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능
  - 최대 1023 컬럼까지 지정 가능
  - SQL Server 2005 버전에 추가된 기능

- 커버드 인덱스와 달리 수직적 탐색에 사용할 수 없음. 정렬도 되지 않음
- 순전히 테이블 랜덤 액세스를 줄이는 용도로 개발됨

### 3.1.6 인덱스 구조 테이블
- **`클러스터형 인덱스`**, **`IOT(Index-Organized Table)`**
  - 랜덤 액세스가 발생하지 않도록 인덱스 구조로 생성된 테이블 

    ![CleanShot 2024-08-01 at 00 38 57](https://github.com/user-attachments/assets/eac78504-0570-4452-a7ca-cc5be2d42f7d)

- **`인덱스 리프 블록에서 테이블 블록에 있어야 할 데이터를 모두 저장`**
  - 인덱스 리프 블록 = 테이블 블록 
- 인위적으로 클러스터링 팩터를 좋게 만드는 방법 → 시퀀셜 데이터 액세스 가능해짐
  - 정렬 상태를 유지하면서 데이터 입력함
  - BETWEEN이나 부등호 조건으로 넓은 범위를 읽을 때 유리함 
- 테이블 생성할 때, `organization index` 작성(기본 테이블은 힙 구조 테이블)

  ![CleanShot 2024-08-01 at 00 41 07](https://github.com/user-attachments/assets/e8d04768-18b5-46a3-ba15-e7d81de2c2cb)

  ![CleanShot 2024-08-01 at 00 41 23](https://github.com/user-attachments/assets/f0ad9008-8b97-4b8c-8c2d-3ef70a273cfd)


### 3.1.7 클러스터 테이블
- 인덱스 클러스터와 해시 클러스터 두가지 종류가 존재함

- **`인덱스 클러스터 테이블`**
  - 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조
  - 한 블록에 모두 담을 수 없을 때는 새로운 블록 할당하여 클러스터 체인으로 연결함
  - 심지어, 여러 테이블 레코드를 같은 블록에 저장할 수도 있음 → 다중 테이블 클러스터 (일반 테이블은 하나의 데이터 블록을 여러 테이블이 공유할 수 없는것과 다름)

    ![CleanShot 2024-08-01 at 00 45 58](https://github.com/user-attachments/assets/80c65187-e5e9-4fbb-b5a1-2bf7b4edd4de)

  - **키 값이 같은 데이터를 같은 공간에 저장해 둘 뿐, IOT나 클러스터 인덱스와는 다름 (정렬된 상태 X)**
 
  - 클러스터 생성

    ![CleanShot 2024-08-01 at 01 00 58](https://github.com/user-attachments/assets/ddf9a5b1-60df-4406-aaf0-ea94beb8c9d6)

  - 클러스터 인덱스 정의

    ![CleanShot 2024-08-01 at 01 01 12](https://github.com/user-attachments/assets/90842892-4e93-4e8f-9a05-cebcc9f565cc)

      - 클러스터에 테이블을 담기 전에 먼저 클러스터 인덱스를 반드시 정의해야함
      - 클러스터 인덱스는 데이터 검색 용도 뿐 아니라 데이터가 저장될 위치를 찾을 때도 사용하기 때문
   
  - 클러스터 테이블 생성

     ![CleanShot 2024-08-01 at 01 00 45](https://github.com/user-attachments/assets/5389a573-fbee-47b4-b784-b88cb9324054)

  - 클러스터 인덱스도 일반 B*Tree 인덱스 구조를 사용하지만, 테이블 레코드를 일일이 가리키지 않고 해당 키 값을 저장하는 첫 번째 데이터 블록을 가리킨다는 점이 다름
    - 즉, 일반 테이블에 생성한 인덱스 레코드는 테이블 레코드와 1:1 대응 관계를 갖지만 클러스터 인덱스는 테이블 레코드와 1:M의 관계를 가짐
    - 따라서, 클러스터 인덱스의 키 값은 항상 유니크함  

      ![CleanShot 2024-08-01 at 01 00 29](https://github.com/user-attachments/assets/55096722-4cba-4bb1-83d6-42cafb9a7a00)

      - 이러한 구조적 특성 때문에 클러스터 인덱스를 스캔하면서 값을 찾을 때는 랜덤 액세스가 값 하나당 한 번씩 밖에 발생하지 않음
        - 클러스터 체인을 스캔하면서 발생하는 랜덤 액세스 제외 
        
  - `클러스터에 도달한 후에는 시퀀셜 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없다는 것이 핵심`

  - 클러스터 인덱스로 조회할 때 실행 계획
    
    ![CleanShot 2024-08-01 at 01 02 25](https://github.com/user-attachments/assets/bbd8253f-ecc9-4f06-ae1f-1ebb2062dbfa)


- **`해시 클러스터 테이블`**
 - 인덱스 클러스터 테이블과는 해시 알고리즘을 사용해 클러스터를 찾아간다는 점만 다름

  ![CleanShot 2024-08-01 at 00 48 59](https://github.com/user-attachments/assets/92131788-f4aa-42e0-882e-4adfbc6ae0db)

  ![CleanShot 2024-08-01 at 00 49 19](https://github.com/user-attachments/assets/4bc760b8-7a68-4d86-adf2-734719a21e94)

## 3.2 부분범위 처리 활용

### 3.2.1 부분범위 처리
- **`데이터를 전송할 때 일정량씩 나누어 전송하는 방식`**

- 다만, `정렬 조건이 있으면 정렬을 완료한 후 전송할 데이터를 나눌 수 있기 때문에 성능 개선이 불가능함`
  - 정렬 조건이 인덱스의 선두에 있으면 부분 범위 처리 가능함
    - 인덱스에서 조회하는 순서대로 전달하면 되기 때문에 전체 확인 및 정렬 작업 없이 나누어 전송 가능하기 때문

- 대량 데이터를 파일로 내려받는다면 어차피 데이터를 모두 전송해야 하므로 Array Size를 크게 하고 Fetch Call을 줄임
- 일부 데이터만 Fetch하다가 멈추는 프로그램은 Array Size를 작게 설정하는 것이 유리함

- **Pagination 전략과 동일한 것 같음**

### 3.2.2 부분범위 처리 구현
- 모든 DBMS는 데이터를 나눠서 전송함. 이 특징을 이용하여 중간에 멈췄다가 사용자의 추가 요청이 있을때마다 데이터를 가져오도록 하는 것은 구현하는 개발자의 몫
- Array Size에 도달하면 멈추었다가 사용자 요청이 있을 때 다시 데이터를 Fetch하는 부분이 필요함
- 보통은 Framework에서 제공하는 기능으로 구현함

### 3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리
- 클라이언트 - DB 서버 2-Tier 환경은 일부만 출력하고 멈출 수 있음
- 클라이언트와 DB 사이에 WAS, AP 서버 등이 존재하는 n-Tire는 클라이언트가 특정 DB 커텍션을 독점할 수 없기 때문에 구현하기 어려움 → 5.3장에서 방법 설명함

## 3.3 인덱스 스캔 효율화
- IOT, 클러스터, 파티션은 테이블 랜덤 액세스를 최소화하는데 매우 효과적인 저장 구조
- 다만, 운영 시스템 환경에서 사용하려면 많은 성능 검증 테스트가 필요하기 때문에 쉽게 적용하기 어려움
- 따라서, 운영 환경에서 보다 손쉽게 활용 가능한 일반적인 튜닝 방안은 **`인덱스 컬럼 추가`** 임
  - 테이블 랜덤 액세스를 줄이는 작업은 단순한데 비해, 인덱스 튜닝 기법은 튜닝 요소가 매우 다양함
 
### 3.3.1 인덱스 탐색
- 인덱스의 탐색은 **`수직적 탐색`** 과 **`수평적 탐색`** 이 있음
- 인덱스의 구조는 아래와 같음

  ![CleanShot 2024-08-10 at 02 23 27](https://github.com/user-attachments/assets/82d52228-9c1c-4532-ac43-01fc0f46c477)

- 인덱스의 탐색 과정을 이해할때 조심해야하는 부분은 탐색은 **`스캔 시작점에서 부터 시작`** 한다는 것
  - 조건을 만족하는 것보다 앞에서부터 시작함

    ![CleanShot 2024-08-10 at 02 26 06](https://github.com/user-attachments/assets/c3101633-7152-4f18-9564-3602a345f6c5)

### 3.3.2 인덱스 스캔 효율성
- **`인덱스 선행 컬럼이 조건절에 없거나 '=' 조건이 아니면 인덱스 스캔 과정에 비효율이 발생함`**
  - 선두는 맨앞, 선행은 상대적으로 앞에 있는 컬럼을 의미함

- 예제

  ![CleanShot 2024-08-10 at 02 29 30](https://github.com/user-attachments/assets/4ed70e54-4fdd-4f4c-82b4-ad5de948b9df)

### 3.3.3 액세스 조건과 필터 조건
![CleanShot 2024-08-10 at 02 32 34](https://github.com/user-attachments/assets/18b1cc74-f042-4d64-b1e9-ef9fd682f621)
- **`인덱스 액세스 조건`** : 인덱스 스캔 범위를 결정하는 조건절(수직적 탐색에서 스캔 시작점과 종료 지점 결정)
- **`인덱스 필터 조건`** : 테이블로 액세스 할지 결정하는 조건절(인데스 컬럼만으로 조건에 만족하는지 판단)
- **`테이블 필터 조건`** : 쿼리 수행 다음 단계로 전달하거나 최종 결과 집합에 포함할지 결정(일단 데이터를 가져온 다음 필터링)

#### 옵티마이저 비용 계산 원리
- **`비용`** = `인덱스 수직적 탐색 비용` + `인덱스 수평적 탐색 비용` + `테이블 랜덤 액세스 비용`
- **`비용`** = `인덱스 루트와 브랜치 레벨에서 읽는 블록 수` + `인덱스 리프 블록을 스캔하는 과정에 읽는 블록 수`+ `테이블 액세스 과정에 읽는 블록 수`

### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성
- 테이블과 달리 인덱스에는 '같은 값'을 갖는 레코드들이 서로 군집해 있음

  ![CleanShot 2024-08-10 at 02 40 29](https://github.com/user-attachments/assets/707f1ed2-f113-4713-81b1-a5200fe6b60e)

- 따라서, '=' 연산자로 조회하면 조건절을 만족하는 레코드는 모두 모여 있음
- 반면에, 어느 하나 누락하거나 '=' 조건이 아닌 연산자로 조회하면 조건절을 만족하는 레코드가 서로 흩어지는 상태가 됨
- 즉, **선행 컬럼이 '='인 조건 상태에서 첫 번째로 나타나는 범위 검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관 없이 흩어짐**
  - 해당 조건이 **`인덱스 액세스 조건`** 임
  - 나머지 컬럼은 `인덱스 필터 조건`이 됨 

  ![CleanShot 2024-08-10 at 02 44 57](https://github.com/user-attachments/assets/ed3b03e6-c4d1-4897-8646-43186471316e)

### 3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율
- 인덱스 스캔 효율은 **`인덱스 컬럼을 모두 등치(=) 조건으로 사용할 때 가장 좋음`**
  - 단, 인덱스 컬럼 중 일부가 조건절에 없거나 등치 조건이 아니더라도 뒤쪽 컬럼일 때는 비효율이 없음

    ![CleanShot 2024-08-10 at 02 47 43](https://github.com/user-attachments/assets/d393b146-1795-42b7-a02b-c95228be9438)

      - 맨 마지막 스캔은 조건을 만족하는 레코드가 더 없음을 확인하기 위한 one-plus 스캔(어쩔 수 없음)

- `인덱스 선행 컬럼이 조건절에 없거나, 부등호, BETWEEN, LIKE 같은 범위 검색 조건이면 인덱스를 스캔하는 단계에서 비효율이 생기게 됨`

    ![CleanShot 2024-08-10 at 02 49 30](https://github.com/user-attachments/assets/c53f64e9-f447-4040-bc80-9b246cbd672a)

- 인덱스 선행 컬럼이 모두 '=' 조건일 때 필요한 범위만 스캔하고 멈출 수 있는 것은, **`조건을 만족하는 레코드가 모두 한데 모여 있기 때문임`**

### 3.3.6 BETWEEN을 IN-List로 전환
- **운영 시스템에서는 인덱스의 구성을 변경하기란 쉬운 일이 아님**
- 이러한 경우에는 **`BETWEEN 조건을 IN-List로 변경해서 개선할 수 있음`**
  
  ![CleanShot 2024-08-10 at 02 52 22](https://github.com/user-attachments/assets/9d1e89ef-18d9-492a-a494-f547bf64a368)

  ![CleanShot 2024-08-10 at 02 52 44](https://github.com/user-attachments/assets/4e39bc23-5161-48f9-8956-0e3e9061b5e9)

    → INLIST ITERATOR 오퍼레이션 발생(IN절의 각 값에 대해 수직 탐색 반복 진행)

  ![CleanShot 2024-08-10 at 02 53 02](https://github.com/user-attachments/assets/04d0fdb5-1fdc-4035-a390-2181d2d1a544)

- 즉, **BETWEEN 조건으로 넓은 범위를 수평적 탐색하기 보다 IN-List로 수직적 탐색을 여러번 하여 불필요한 범위를 넘어가는 것이 유리할 수 있음**
  - Index Skip Scan과 유사

#### 주의 사항
  - `IN-List 항목이 늘어날 수 있으면 불가능` (BETWEEN 값 사이에 현재 알고 있는 값 이외에 추가 발생)
    - IN-List 의 값을 코드로 관리하고 있는 경우, NL 방식의 조인 문이나 서브 쿼리로 구현 가능
          ![CleanShot 2024-08-10 at 02 57 35](https://github.com/user-attachments/assets/bd50255d-56a6-4ebe-8140-5ef804d721db)

  - `인덱스 스캔 과정에서 선택되는 레코드들이 멀리 떨어져있을 때 유용함`
  - `IN-List 개수가 많으면 리프 블록 탐색 스캔 비용보다 루트에서 브랜치 블록까지를 반복 스캔하는 I/O 비용이 클 수 있음`
 
    ![CleanShot 2024-08-10 at 02 59 35](https://github.com/user-attachments/assets/bca949f3-687b-4d99-a8d1-a2ce3850bc6b)

    
### 3.3.7 Index Skip Scan 활용
- 선두 컬럼이 BETWEEN 조건이어서 나머지 검색 조건을 만족하는 데이터들이 멀리 떨어져있는 경우, IN-List 대신 **`Index Skip Scan`** 으로 개선 가능
- 블록 I/O 비교: 인덱스 변경 > Skip Scan > IN-LIST >> Between

  ![CleanShot 2024-08-10 at 03 02 57](https://github.com/user-attachments/assets/93905fa8-1695-4631-9c6e-bb7fb3ebde40)

### 3.3.8 IN 조건은 '='인가
- **`IN 조건은 '='이 아님`**
  - 따라서, 인덱스를 어떻게 구성하는냐에 따라 성능이 달라질 수 있음
- '='이 되려면 IN-LIST Iterator로 풀어서 액세스 조건으로 만들어야 함, 그렇지 않으면 IN 조건은 필터 조건임
- 다만, IN 조건이 액세스 조건이 된다고 항상 효과적인 것이 아님
- `NUM_INDEX_KEYS` 힌트로 IN-List 액세스 조건 또는 필터 조건으로 유도할 수 있음

### 3.3.9 BETWEEN과 LIKE 스캔 범위 비교
- **`LIKE보다 BETWEEN을 사용하는 게 나음`** 
- BETWEEN은 양 끝단의 레코드 시작점, 멈추는 지점이 설정되여 효율적일 수 있음
- 그러나 LIKE는 양 끝단의 조건 레코드를 모두 훑어야함

- 예제

  ![CleanShot 2024-08-10 at 03 07 38](https://github.com/user-attachments/assets/db6e6ffe-168c-4b76-8ae8-26339e4329c0)

   - **`where 판매월 LIKE '2019%'`** vs **`where 판매월 BETWEEN '201901' and '201912'`**
   - **옵티마이저는 201900 혹은 201913 이 있는지 없는지 알 수 없음** 따라서, 추가적으로 더 스캔함

### 3.3.10 범위 조건 검색을 남용할 때 생기는 비효율
- 옵션 조건을 처리하기 위해 LIKE나 BETWEEN을 남발하는 경우가 있음

- 예제
  
  ```sql
  <쿼리1>회사코드, 지역코드, 상품명을 모두 입력할 때
  SELECT 고객ID, 상품명, 지역코드, ...
  FROM 가입상품
  WHERE 회사코드 =: com
  AND 지역코드 =: reg
  AND 상품명 LIKE :prod || '%'
  
  <쿼리2> 회사코드, 상품명을 모두 입력할 때
  SELECT 고객ID, 상품명, 지역코드, ...
  FROM 가입상품
  WHERE 회사코드 =: com
  AND 상품명 LIKE :prod || '%'
  ```
  
  ```sql
  <쿼리3> 회사코드, 상품명, 지역코드,,,
  SELECT 고객ID, 상품명, 지역코드, ...
  FROM 가입상품
  WHERE 회사코드 =: com
  AND 지역코드 LIKE :reg || '%'
  AND 상품명 LIKE :prod || '%'
  ```

    - 2가지 상황에 따라 처리해야하는 쿼리(쿼리1과 쿼리2 상황)를 효율적으로 개발하기 위해 쿼리 3으로 변경하면 지역코드가 입력되어도 지역 코드가 액세스 조건으로 사용되지 못하고 필터 조건으로 사용됨(마지막 상품명이 '%'여서 전부 스캔이 진행됨)

⇒ **`개발 생산성은 좋아질지 몰라도 인덱스 스캔의 비효율이 생김`** . 특히 대량 테이블을 넓은 범위로 검색할 때 영향이 매우 클 수도 있음(신중하게 하자..)

### 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교
- 옵션처리를 위해 아래와 같이 다양한 방법이 있음

1. **`OR 조건 활용`**
    
  ```sql
    select * from 거래
    where (:cust_id is null or 고객ID = :cust_id)
    and 거래일자 between :dt1 and dt2
  ```
    
  - 해당 경우는 옵티마이저의 OR Expansion이 자동으로 적용되지 않음
    - 선행 조건에 OR 사용시 인덱스 사용X
    - 후행 조건에서 사용시, 필터로 사용되지만 oracle는 null을 인덱스에 저장하지 않기 때문에 테이블 액세스 단계에서 필터링
    - 인덱스에 포함되지 않은 컬럼에 대해 옵션 조건은 어차피 테이블 스캔에서 필터링해야하므로 써도 상관없음
    
    ⇒ 즉,
      - 인덱스 액세스 조건으로 사용 불가
      - 인덱스 필터 조건으로도 사용 불가
      - 오직, 테이블 필터 조건으로만 사용 가능함 (NotNull 조건 컬럼은 18c부터 인덱스 필터 조건 사용 가능)
    
  - 아래의 경우에는 OR Expansion을 통해 인덱스 사용 가능
    
    ```sql
      select * from 거래 where 고객ID = :custd_id
      and ((:dt_type = 'A' AND 거래일자 between :dt1 and :dt2))
          or
          ((:dt_type = 'B' AND 거래일자 between :dt1 and :dt2))
    ```

    ![CleanShot 2024-08-10 at 03 27 11](https://github.com/user-attachments/assets/8d11d48d-677c-464b-b2da-149d011313c3)

2. **`LIKE/BETWEEN 조건 활용`**
- 아래 예제 처럼 변별력이 좋은 필수 조건이 있는 상황(당일 등록 상품은 소수)에서 LIKE/BETWEEN 패턴을 사용하는 것도 나쁘지는 않음
  - 필수 조건 컬럼을 인덱스 선두에 두고 액세스 조건으로 사용하면, LIKE/BETWEEN이 인덱스 필터 조건이어도 충분히 좋은 성능을 낼 수 있음
 
- 예제      
    ```sql
      -- 인덱스 : 상품대분류코드 + 상품코드
      select * from 상품
      where 상품대분류코드 = :prd_lcls_cd  // 필수 조건
      and 상품코드 like :prd_cd || '%' // 옵션 조건
    ```
    
- 따라서, LIKE/BETWEEN 을 사용할 때 아래 조건에 속하는지 반드시 점검해야함(BETWEEN은 위의 2개 확인)
  - **`인덱스 선두 컬럼`**
    - 값이 입력되지 않으면 인덱스에서 모두 검색해서 필터링해야함
  - **`NULL 허용 컬럼`**
    - 결과 집합에 오류가 생김(NULL 데이터는 like '%' 및 BETWEEN 조건에 검색되지 않음)
  - **`숫자형 컬럼`**
    - '%'은 문자 비교 연산이라서 숫자형 컬럼은 자동 형변환 → 인덱스 사용 X
  - **`가변 길이 컬럼`**
    - 입력값이 있어도 여러 값이 의도하지 않게 검색될 수 있음

3. **`UNION ALL 활용`**
- 아래 예제 처럼 UNION ALL을 이용할 수 있음
    
```sql
  select * from 거래
  where :cust_id is null
  and 거래일자 between :dt1 and :dt2  -- 거래 일자가 선두인 인덱스 사용
  union all
  select * from 거래
  where :cust_id is not null
  and 거래일자 between :dt1 and :dt2   -- 고객ID가 선두인 인덱스 사용
```
    
→ :cust_id 변수에 값을 입력했는지 하지 않았는지에 따라 두 SQL 중 하나만 실행되는 방식

- null 허용 컬럼이어도 문제 없음
- 두 경우 모두 옵션 조건 컬럼도 인덱스 액세스 조건으로 사용함
- SQL 코딩량이 길어진다는 단점이 있음

4. **`NVL/DECODE 함수 활용`**
- NVL/DECODE 함수도 옵션 조건에 많이 사용하는 패턴 중 하나
    
```sql
  select * from 거래
  where 고객ID = nvl(:cust_id, 고객ID)
  and 거래일자 between :dt1 and :dt2
  
  또는
  
  select * from 고객
  where 고객ID = decode(:cuxst_id, null, 고객ID, :cust_id)
  and 거래일자 between :dt1 and :dt2
```
    
→ :cust_id 값이 없으면 거래일자가 선두인 인덱스 이용, 있으면 고객ID+거래일자 인덱스 사용
    
- NVL, DECODE 둘 다 실행계획은 동일함

  ![CleanShot 2024-08-10 at 03 44 56](https://github.com/user-attachments/assets/6c66cd06-a9e9-4f33-abfe-ee35da67b7ae)

- 고객ID를 가공했는데도 인덱스 사용이 가능한 이유는 OR Expansion 쿼리 변환이 일어났기 때문임
- 옵션 조건 컬러도 인덱스 액세스 조건으로 사용할 수 있음
- UNION ALL보다 단순하면서 UNION ALL과 동일한 성능을 냄
  - 하지만, NULL 허용 컬럼에서는 사용할 수 없음
- NVL/DECODE 함수를 여러개 사용하면 그 중 가장 변별력이 좋은 컬럼 기준으로 한 번만 OR Expansion이 일어남

5. **`Dynamic SQL`**
- **Dynamic SQL 쓸 수 있으면 사실 옵션 조건에 '=' 사용 가능함**
  - 보통 일반적인 프레임워크에서는 지원하기 때문에, 대부분의 상황에서는 해당 방식을 사용

    ![CleanShot 2024-08-10 at 03 44 08](https://github.com/user-attachments/assets/faf04bd7-c612-44a9-87fc-fab0b4e092ea)

- 다만, 금융권과 같이 Dynamic SQL을 허용하지 않는 곳도 있고, 허용하더라도 힌트로 액세스 경로를 고정하려고 할 때 동적으로 구성된 조건절과 서로 상충할 수 있어서 알아둘 필요는 있음

#### 옵션 조건 처리은 다루기 어려운 주제, 지금까지 나온 여러 방식의 장단점을 이해하여 상황에 따라 적절하게 선택할 수 있는 게 중요
- 인덱스 구조와 탐색 원리, 특히 인덱스 스캔 효율화 원리를 정확하게 이해하는 것이 중요! 

### 3.3.12 함수호출부하 해소를 위한 인덱스 구성
- PL/SQL 사용자 정의 함수는 개발자들이 일반적으로 생각하는 것 이상으로 느림
  - `가상머신(VM) 상에서 실행되는 인터프리터 언어`
  - `호출 시마다 컨텍스트 스위칭 발생`
  - `내장 SQL에 대한 Recursive Call 발생`

- 따라서, 쿼리 내에 풀어서 쓰길 권장
  - 함수 내부 로직이 너무 복잡하면 그대로 쓸 수 밖에 없지만, 그런 경우엔 효과적인 인덱스 구성을 통해 함수 호출 횟수를 줄이는 방안을 적용해야함 (액세스 조건을 골려한 인덱스 설계, 등)

## 3.4 인덱스 설계

### 3.4.1 인덱스 설계가 어려운 이유
- 인덱스는 무제한으로 생성할 수 있는 것이 아님
- 인덱스가 많으면 많은 문제가 발생할 수 있음
  - DML 성능 저하(TPS 저하)
    - 인덱스 갱신 오버헤드, 인덱스 분할 등 
  - 데이터베이스 사이즈 증가(디스크 공간 낭비)
  - 데이터베이스 관리 및 운영 비용 상승(백업,복제, 재구성 등)
- 따라서, 인덱스의 양을 적절히 가져가면서 SQL에 최적화된 인덱스를 생성해야하기 때문에 초기에 설계하기 쉽지 않음
- 인덱스 설계는 시스템 전체 시각에서 종합적, 전략적으로 접근해야함
- 인덱스 추가는 시스템에 부하를 주고, 인덱스 변경은 운영 리스크가 있음
  - 변경하기 쉽지 않기 때문에, **`개발 단계에서 인덱스를 최적으로 설계하는 것이 중요함`**

### 3.4.2 가장 중요한 두 가지 선택 기준
1. **`조건절에 항상 사용하거나, 자주 사용되는 컬럼을 선정한다`**

2. **`'=' 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다`**

→ 인덱스 스캔 효율을 고려한 설계

### 3.4.3 스캔 효율성 이외의 판단 기준
- 다만, 위의 공식을 단순하게 적용하기에는 실무에서는 그렇게 간단하지는 않음
- 공식대로 하려다가, 오히려 인덱스 개수가 더 늘어나는 현상이 발생하기도 함

#### 인덱스 스캔 효율성 외에 고려해야할 판단기준
- 수행 빈도
  - NL 조인을 하는 경우 Inner 쪽 스캔
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하(=기존 인덱스 개수, 초당 DML 발생량, 자주 갱신하는 컬럼 포함 여부 등)
- 저장 공간
- 인덱스 관리 비용 등

### 3.4.4 공식을 초월한 전략적 설계
- 조건절 패턴이 열 개 있을 때, 패턴마다 인덱스를 하나씩 만들 수는 없음
  → 최적을 달성해야 할 핵심 액세스 경로 한 두 개를 전략적으로 선택해서 최적 인덱스 설계
  → 나머지 액세스 경로는 약간의 비효율이 있더라도 목표 성능을 만족하는 수준으로 인덱스를 구성

### 3.4.5 소트 연산을 생략하기 위한  컬럼 추가
- 인덱스는 정렬되어 있어서 소트 연산 생략 가능
- 정렬을 위해 인덱스를 사용하기도 함

#### I/O 연산 최소화 & 소트 연산 생략
- '=' 연산자로 사용한 조건절 컬럼 선정
- ORDER BY 절에 기술한 컬럼 추가
- '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정
  
#### IN 조건은 '='이 아니다
- 소트 연산을 생략하려면 IN-List Iterator 방식으로 풀려선 안됨
  - 정렬 문제가 있음 
- IN 조건절을 인덱스 액세스 조건X, 필터 조건 O

### 3.4.6 결합 인덱스 선택도
- 선택도: **`전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율`**
  - 선택도 * 총 레코드수 = 카디널리티
- 인덱스 생성 여부를 결정할 때 선택도가 충분히 낮은지가 중요한 판단 기준
- 결합 인덱스 컬럼간 순서에 선택도가 중요할까? 
    - ex) WHERE 성별 =: gender AND 고객번호 =: cust_id
    
    → 인덱스 액세스 조건이니까 무관함. 즉, 선택도 높은 걸 앞에 두는 노력은 의미없거나 손해일수도 있음
    
- **`항상 사용하는` 컬럼을 앞쪽에 두고 그중 '=' 조건을 앞쪽에 위치시키는 것이 중요**

⇒ 인덱스 생성 여부에는 선택도가 중요하지만 **`컬럼 간 순서에는 각 컬럼의 선택도보다 필수 조건 여부, 연산자 형태가 더 중요한 판단 기준임`**

### 3.4.7 중복 인덱스 제거
- 직접 책을 보고 인덱스의 중복을 제거하는 연습하기 바람
- 핵심은 약간의 비효율을 감소하더라도 불필요한 인덱스는 제거하자
- 원리를 알면 필요 없는 인덱스 목록이 보일 것

### 3.4.8 인덱스 설계도 작성
- **`시스템 전체 효율`** 을 고려해야하기 때문에 설계도가 필요함

  ![CleanShot 2024-08-13 at 22 56 03](https://github.com/user-attachments/assets/18daa37c-4468-4d05-b0c2-2bce49bb1963)

- 인덱스 설계 전에 파티션 설계를 먼저 진행하거나 병행해야 제대로 된 인덱스 전략을 수립할 수 있음
