# 3장. 인덱스 튜닝

SQL 튜닝은 랜덤I/O 액세스와의 전쟁이다.

모든 최적화가 랜덤 I/O를 얼마나 줄이느냐에 관건되어있다. 

## 3.1 테이블 액세스 최소화

### 3.1.1 테이블 랜덤 액세스

수천만 수억건이 있어도 인덱스를 사용하는 경우 빠른경우가 있꼬, 인덱스를 이용하니 풀 테이블 스캔보다 느릴때도 있다.



인덱스 ROWID는 물리적 주소? 논리적 주소?

아래는 인덱스를 이용해 테이블을 액세스하는 실행계획이다.

SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면 인덱스를 스캔한 후 반드시 테이블에 액세스 한다.

```sql
-- oracle
------------------------------------------------------------------------------------
| Id  | Operation                    | Name        | Rows  | Bytes | Cost (%CPU)|
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |             |    10 |   130 |     5   (0)|
|   1 |  TABLE ACCESS BY INDEX ROWID | MY_TABLE    |    10 |   130 |     5   (0)|
|*  2 |   INDEX RANGE SCAN           | MY_INDEX    |    10 |       |     3   (0)|
------------------------------------------------------------------------------------


-- mysql
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | my_table| NULL       | range | my_index      | my_index| 4       | const |   10 |   100.00 | Using where |
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+

-- postgresql
---------------------------------------------------------
 Index Scan using my_index on my_table  (cost=0.29..8.50 rows=1 width=10)
   Index Cond: (col1 = 'value'::text)
---------------------------------------------------------

```

인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾은 후, 거기서 테이블 레코드를 찾아가기 위한 주소값인 ROWID를 얻고 조회하려는 이유이다.

인덱스 ROWID는 논리적 주소에 가깝다. 물리적으로 직접연결되지 않고, 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고있다. 

* 포인터가 아니다. 물리적으로 연결된 구조도 아니다. 찾아가기 위한 위치 정보를 담는다.
* ex) 7번 데이터 파일 123번 블록 10번째 레코드 -> Data Block Address라고도 한다

**즉 ROWID를 이용한 테이블 액세스가 생각만큼 빠르지가 않다.** 

> mysql에서는 유사한 개념으로 클러스터링 테이블, 클러스터링 인덱스가 사용된다
>
> postgresql에서는 ctid(튜플 아이덴티파이어)라는 시스템 컬럼을 사용한다. 
>
> - (블록 번호, 블록 내 튜플 인덱스) 형태 

### 3.1.2 인덱스 클러스터링 팩터

인덱스 클러스터링 팩터(cf)란 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다. 

![image-20240707195633040](./images//image-20240707195633040.png)

위 그림은, 인덱스 클러스터링 팩터가 가장 좋은 상태를 도식화 한 것으로써, 인덱스 레코드 정렬 순서와 테이블 레코드 정렬 순서가 100% 일치하는것을 볼 수 있다.

반면 아래는 인덱스 레코드 정렬 순서와 테이블 레코드 순서가 일치하지 않는 나쁜 상태이다.

![image-20240707195716467](./images//image-20240707195716467.png)

cf가 좋을수록 검색 효율이 좋다. 테이블 액세스량에 비해 블록 I/o가 적게 발생하기 때문이다. 

![image-20240707195804531](./images//image-20240707195804531.png)

* 굵은 실선은 실제 블록 I/O 발생하는 경우, 가는 점선은 블록을 찾아가는 과정(논리적 블록 I/O) 없이 포인터로 바로 액세스 하는 경우

#### 클러스터링 팩터가 좋은 경우(낮은 경우):

- 인덱스의 순서와 테이블 데이터의 물리적 순서가 유사하다.
- 한 번의 인덱스 스캔으로 읽어들인 블록이 테이블에서 연속적으로 저장된 데이터를 참조한다. (블록단위로 데이터를 읽으니까.)
- 디스크 I/O가 최소화되며, 테이블 블록을 적게 읽게 된다.
- 이로인해 전체 성능이 향상된다 

#### 클러스터링 팩터가 나쁜 경우(높은 경우):

- 인덱스의 순서와 테이블 데이터의 물리적 순서가 일치하지 않는다.
- 인덱스 스캔 시 테이블의 여러 블록을 불연속적으로 읽어야 한다. (I/O가 발생)
- 디스크 I/O가 증가하며, 더 많은 테이블 블록을 읽어야 한다..
- 이로 인해 전체 성능이 저하된다.

클러스터링 팩터가 낮으면 인덱스 스캔 후 테이블 블록에 접근할 때 물리적으로 인접한 블록에 접근하게 되므로 디스크 I/O가 줄어들고 성능이 향상된다. 반대로 클러스터링 팩터가 높으면 여러 블록에 불연속적으로 접근해야 하므로 디스크 I/O가 증가하여 성능이 저하된다. (랜덤 I/O 액세스 )

* MySQL의 주요 스토리지 엔진인 InnoDB는 클러스터형 인덱스를 사용하여 기본 키에 따라 데이터를 물리적으로 정렬하여 저장하므로  기본 키를 기준으로 하는 쿼리에서 클러스터링 팩터가 낮아 성능이 향상된다.

* **Postgre의 경우 Primary Key에 대해 "Index"를 자동으로 생성하지만,**

  **이는 Cluster Index가 아니며 따라서 데이터의 정렬을 보장하지 않는다.**

  * cluster 명령어를 지원하긴 하지만, 일회성일뿐 이후 데이터들은 게속 주기적으로 재정렬되진 않는다 - https://www.postgresql.org/docs/14/sql-cluster.html

### 3.1.3 인덱스 손익분기점

인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용이다. 읽어야 할 데이터가 일정량을 넘어서면 테이블 풀 스캔보다 느려진다.

인덱스 레인지 스캔의 테이블 액세스가, 테이블 풀 스캔보다 느려지는 지점을 인덱스 손익 분기점이라고 한다.

인덱스를 이용한 테이블 액세스가 Table Pull Scan보다 더 느려지게 만드는 가장 핵심적인

두 가지 요인은 다음과 같다.

- ﻿﻿Table Pall Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스 는 랜덤 액세스 방식이다.
- ﻿﻿Table flall Scan은 Multiblock I/0인 반면, 인덱스 ROWID를 이용한 테이블 액세 스는 Single Block I/O 방식이다.

![image-20240707200557325](./images//image-20240707200557325.png)

* 손익분기점 %(퍼센트)
* 가져와야 할 데이터가 만건만 넘어도 시퀀셜 액세스와 멀티블록 I/O를 이용한 풀 테이블 스캔이 빠를 수 있다. 



### OLTP 프로그램 튜닝 vs 배치 프로그램 튜닝

OLTP는 보통 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 사용하는것이 중요하다. 

배치 프로그램은 항상 전체범위 기준으로 튜닝해야 한다. 처리대상중 일부가 목표가 아닌, 전체를 빠르게 처리하는것을 목표로 삼아야 한다.

* 이경우 FULL SCAN과 해시 조인이 유리하다.

그렇다고 배치 프로그램에서 초 대용량 테이블을 FULL SCAN하면 오래 기다려야 하므로 파티셔닝, 병렬처리 등을 골라 풀스캔해서 빠르게 처리하는것이 좋다. 

### 3.1.4 인덱스 컬럼 추가

EMP 테이블에 DEPTNO + JOB으로 구성한 인덱스가 있다.

이때 아래 쿼리를 수행하려고 한다.

![image-20240707201533241](./images//image-20240707201533241.png)

```
SELECT * FROM EMP WHERE DEPNO = 30 AND sal >= 2000
```

만족하는 사원은 1명뿐인데, sal 조건때문에 테이블을 6번 액세스 했다. 

![image-20240707201626916](./images//image-20240707201626916.png)

이런경우 그냥 기존 인덱스에 SAL 컬럼을 추가해주는것만으로도 큰 효과를 얻을 수 있다. 인덱스 스캔은 줄지 않지만 테이블 I/O가 줄기 때문이다 

### 3.1.5 인덱스만 읽고 처리

위 사례는 액세스 단계 필터 조건에 의해 버려지는 레코드가 많을 때, 인덱스에 컬럼을 추가함으로써 얻는 성능 효과를 보았다.

그러나 테이블 랜덤 I/O가 많아도, 필터 조건에 의해 버려지는 레코드가 없다면 그것은 비효율적인것은 아니다.

이때는 어떻게 튜닝해야 할까?

반드시 성능을 개선해야 한다면, 쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 아예 발생하지 않게 하는 방법을 고려할 수 있다.

-> 커버링 인덱스. 



### 3.1.6 인덱스 구조 테이블

![image-20240707202005530](./images//image-20240707202005530.png)

랜덤 액세스가 발생하지 않도록 테이블을 인덱스 구조로 생성한 것을 IOT(Index-Organized Table)이라고 부른다.

테이블 블록에 있어야할 데이터를 인덱스 리프 블록에 모두 저장하고 있다. 

즉 인덱스 리프블록이 곧 데이터블록이다. 

* 테이블 데이터가 기본 키에 따라 인덱스에 물리적으로 정렬되어 저장된다.

* 보조 인덱스 같은경우, pk를 통해 데이터를 다시 조회해야 한다.  

* 세컨더리 인덱스의 리프 노드에는 인덱스 키 값과 함께 이 논리적 ROWID가 저장된다. 

* 세컨더리 인덱스를 통해 조회 시, 먼저 논리적 ROWID를 얻는다.

  이 논리적 ROWID를 사용하여 IOT의 프라이머리 키 인덱스를 검색한다.

  프라이머리 키 인덱스에서 실제 데이터 레코드를 찾는다.

> Mysql의 클러스터링 테이블과는 조금 다르다. 
> 용어와 구현 세부 사항이 다를 뿐, 개념적으로는 유사한 방식으로 데이터를 저장하고 접근한다.  



### 3.1.7 클러스터 테이블

오라클의 클러스터 테이블에는 인덱스 클러스터와 해시 클러스터 두가지가 있다.



인덱스 클러스터 테이블은 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조다. 

> 이름 때문에 SQL 서버나 Sybase에서 말하는 '클러스터형 인덱스(Clustered Index) 와 같다고 생각할지 모르지만 클러스터형 인덱스는 오히려 IOT에 가깝다. 
>
> 오라클 클러스터는 키 값이 같은 데이터를 같은 공간에 저장해 둘 뿐, IOT나 클러스터형 인덱스처럼 정렬하지는 않는다.

![image-20240707202920195](./images//image-20240707202920195.png)

일반 테이블에 생성한 인덱스 레코드는 테이블 레코드와 1:1관계를 갖지만, 클러스터 인덱스는 1:M 관게를 갖는다. (블록을 가리키는 말 같은데..? )

클러스터 인덱스의 키 값은 항상 Unique하다. 

이런 특성 때문에 클러스터 인덱스 스캔시 랜덤 액세스가 값 하나당 한번씩 밖에 발생 안하고, 도달해서 시퀀셜 스캔하기 때문에 비효율이 없다. 



**해시 클러스터 테이블**

해시 클러스터는 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아간다는점만 다르다.

![image-20240707203550072](./images//image-20240707203550072.png)

## 3.2 부분범위 처리 활용

부분범위 처리원리를 활용하면 인덱스로 액세스할 대상 레코드가 아무리 많아도 아주 빠른 응답속도를 낼 수 있다. 

### 3.2.1 부분범위 처리

모든 DBMS는 데이터를 조금씩 나눠서 전송한다. 페이징과는 다르다. 결과집합을 조금씩 나눠서 전송한다

* dbms마다 다른듯?

중간에 멈췄다가 사용자의 추가 요청이 있을때마다 데이터를 가져오도록 구현한다. 

```java
String sql = "select...from..";
Statement stmt = con.createStatement();
stmt.setFetchSize(10);
```

