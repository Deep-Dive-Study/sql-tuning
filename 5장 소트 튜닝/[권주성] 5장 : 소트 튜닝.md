# 5장 소트 튜닝
## 5.1 소트 연산에 대한 이해
## 5.1.1 소트 수행 과정 
- `소트(Sort)`는 기본적으로 `PGA 에 할당한` **`Sort Area`** 에서 이루어짐
- `메모리 공간인 Sort Area 가 다 차면`, **`디스크 Temp 테이블 스페이스를 활용함`**
- Sort Area에서 작업을 완료할 수 있는지에 따라 **소트를 두가지 유형으로 분류** 할 수 있음
    - **`메모리 소트(In-Memory Sort)`** : `Internal Sort` , 전체 데이터의 정렬 작업을 메모리 내에서 완료하는 것
    - **`디스크 소트(To-Disk Sork)`** :  `External Sort` , 할당 받은 Sort Area 내에서 정렬을 완료하지 못하여, 디스크 공간까지 사용한 경우

#### 디스크 소트 과정

  <img width="443" alt="CleanShot 2024-09-08 at 17 25 46@2x" src="https://github.com/user-attachments/assets/248b7fa8-c95c-4880-a2b2-45d2c0b66661">

1. 소트할 대상 집합을 SGA 버퍼 캐시를 통해 읽는다.
2. Sort Area에서 정렬을 시도한다.
   - 양이 많아 Sort Area에서 처리하지 못한 경우, 정렬된 중간 집합(Sort Run)을 Temp 테이블 스페이스에서 임시 세그먼트를 만들어 저장한다.
3. 최종 결과집합을 얻기 위해 Merge한다.   


#### 소트 연산은 `메모리 집약적`이며, `CPU 집약적`임. 뿐만 아니라 데이터가 많으면 `디스크 I/O도 많아`짐
  - 즉, **`쿼리 성능을 좌우`** 하며, **`많은 서버 리소스를 사용`** 하는 작업
  - 이뿐만 아니라, **`부분 범위 처리를 불가능하게 함으로써`** OLTP 환경에서 어플리케이션 성능을 저하시키는 주요인이기 되기도함

- 따라서, 소트에 대해 잘 이해하고 있는 것은 매우 중요하며, 될 수 있으면 소트가 발생하지 않도록 SQL을 작성해야함.
  - 만약, 소트가 불가피한 경우에는 메모리 내에서 수행 완료할 수 있도록 해야함

### 5.1.2 소트 오퍼레이션
- 소트를 발생 시킬 수 있는 오퍼레이션
  - **`Sort Aggregate`** : 전체 로우를 대상으로 집계를 수행
    - 실제로 정렬하진 않으나, Sort Area를 사용함 

    <img width="418" alt="CleanShot 2024-09-08 at 17 37 56@2x" src="https://github.com/user-attachments/assets/fba5f310-003f-40de-9f58-ffe9a542da7b">

  - **`Sort Order By`** : 데이터를 정렬하는 경우

    <img width="407" alt="CleanShot 2024-09-08 at 17 39 23@2x" src="https://github.com/user-attachments/assets/652fde62-dfd0-4cfb-a3c6-4b6ce68dc1a2">

  - **`Sort Group By`** : 소팅 알고리즘을 사용해 그룹별 집계를 수행하는 경우
    - 실제 정렬이 일어나는 것은 아니기 때문에, 정렬 순서를 보장해주지 않음 (자세한 내용은 책 참조) 

    <img width="426" alt="CleanShot 2024-09-08 at 17 40 18@2x" src="https://github.com/user-attachments/assets/1b228cb4-fd8f-4813-acd4-bd12198cf8d5">

  - **`Sort Unique`** : 서브쿼리 Unnesting 과정에서 메인 쿼리와 조인하기 전에 중복 레코드를 제거해야하는 경우

    <img width="433" alt="CleanShot 2024-09-08 at 17 46 10@2x" src="https://github.com/user-attachments/assets/1341219d-11ac-4389-a9c5-9ea00494920c">

  - **`Sort Join`** : 소트 머지 조인을 수행하는 경우

    <img width="412" alt="CleanShot 2024-09-08 at 17 45 54@2x" src="https://github.com/user-attachments/assets/0dcc9156-a02d-4f5b-874c-463d90040525">
  
  - **`Window Sort`** : 윈도우 함수(=분석 함수)를 수행하는 경우

     <img width="408" alt="CleanShot 2024-09-08 at 17 45 03@2x" src="https://github.com/user-attachments/assets/6376560f-4fe2-4065-b46c-5af5c27041a3">

## 5.2 소트가 발생하지 않도록 SQL 작성
- SQL 작성할 때 불필요한 소트가 발생하지 않도록 주의해야함
- Union, Minus, Distinct 연산자는 중복 레코드를 제거하기 위해 소트 연산을 발생 시킴으로 꼭 필요한 경우에만 사용하는 것이 좋음
  - 성능에 문제가 있는 경우, 피할 수 있는 방법을 모색해야함
- 조인 방식도 잘 선택해야함 

### 5.2.1 Union vs Union ALl
- **`Union`**
    - 옵티마이저는 상단과 하단 `두 집합 간 중복을 제거하려고 소트 작업을 수행`함

- **`Union All`**
    - `중복을 확인하지 않고 두 집합을 단순히 결합`함
    - 따라서, 별도의 소트 작업을 수행하지 않음
    - 두 집합이 상호 배타적일때 사용해도 됨
      - 결과가 달라질 수 있기 때문에 주의가 필요함
      - 이를 정확히 판단하기 위해서는 데이터 모델에 대한 이해와 집합적 사고가 필요함 

- **`예시`**

  <img width="453" alt="CleanShot 2024-09-08 at 17 54 18@2x" src="https://github.com/user-attachments/assets/b649ebb7-49b8-434e-887f-d626b6728948">

 - 위 쿼리는 두 집합이 상호배타적이므로 Union 대신 Union All을 사용해도 됨

     <img width="394" alt="CleanShot 2024-09-08 at 17 54 35@2x" src="https://github.com/user-attachments/assets/ced0da38-2b8a-4245-aae1-79f4d070ee5e">

- 아래 쿼리는 상단과 하단 집합 사이에 인스턴스 중복 가능성이 있기 때문에 사용하면 안됨

  <img width="403" alt="CleanShot 2024-09-08 at 17 55 16@2x" src="https://github.com/user-attachments/assets/a2f543fe-d883-451c-a8b3-0a9bb7dfd6cb">

  - 결제 일자와 주문일자 조건은 상호배타적 조건이 아니기 때문. 변경시 결제일자와 주문일자가 같은 결제 데이터가 중복해서 출력됨

    <img width="420" alt="CleanShot 2024-09-08 at 17 56 29@2x" src="https://github.com/user-attachments/assets/445ad037-c75b-49e4-8f98-9234a87a2166">

### 5.2.2 Exist 활용
- 종종 중복을 제거 하려고 **`Distinct`** 를 사용하는데, 이보다 가능하면 **`Exist`** 를 사용하는 것이 좋음
  - **`Distinct`**
    - 조건에 해당하는 데이터를 모두 읽어서 중복을 제거
      - 부분범위 처리가 불가능. 모든 데이터를 읽는 과정에서 많은 I/O 가 발생함
  - **`Exist`**
    - Exist 서브쿼리는 데이터의 존재 여부만 확인하면 되기 떄문에 모든 데이터를 읽지 않음

  <img width="420" alt="CleanShot 2024-09-08 at 18 14 31@2x" src="https://github.com/user-attachments/assets/69b30ec0-ee51-4c61-808b-3fa38f152555">
  
  <img width="435" alt="CleanShot 2024-09-08 at 18 14 47@2x" src="https://github.com/user-attachments/assets/912e6b8a-7bc8-4e0e-bd5f-a9e162c69afa">

- Distinct, Minus 연산자를 사용한 쿼리는 대부분 Exist 서브쿼리로 변환 가능함
    <img width="409" alt="CleanShot 2024-09-08 at 18 15 09@2x" src="https://github.com/user-attachments/assets/c92c372a-5a69-4e9d-aac7-1f52b84ca29b">

### 5.2.3 조인 방식 변경
- 정렬 기준이 조인 키 컬럼이면 소트 머지 조인도 Sort Order By 연산을 생략할 수 있음

- 예시

  <img width="440" alt="CleanShot 2024-09-08 at 18 08 36@2x" src="https://github.com/user-attachments/assets/004cfb5d-cd47-4cd2-9995-1e30a95e2b57">

    - 위 쿼리에서 Hash Join 대신 NL 조인으로 변경하면, 소트 연산을 생략할 수 있음
    - 이는 지점ID 조건을 만족하는 데이터가 많고 부분 범위 처리 가능한 상황에서 큰 성능 개선 효과를 얻을 수 있음

      <img width="419" alt="CleanShot 2024-09-08 at 18 13 10@2x" src="https://github.com/user-attachments/assets/d857fc6c-cf00-4460-901d-f794b57512b4">
  
