# 5.1 소트 연산에 대한 이해

소트는 PGA의 Sort Area에서 이루어진다. (꽉차면 Temp 테이블스페이스)

- 메모리 소트 : 전체 데이터 정렬 작업을 메모리 내에서 완료하는 것 (Internal Sort)
- 디스크 소트 : Sort Area 내에서 완료하지 못해 디스크 공간까지 활용하는 경우 (External Sort)

![image](https://github.com/user-attachments/assets/a2fe7abb-27ff-4697-a4d0-8d53287d972d)

1. SGA 버퍼캐시를 통해 소트할 대상 집합을 읽어들인다.
2. PGA의 Sort Area에서 정렬을 시도하고, 공간이 부족하면 Temp 세그먼트 단위로 테이블스페이스를 사용한다.
3. 세그먼트별 정렬 후 Merge 하여 PGA에서 클라이언트로 전송한다.

소트 연산은 메모리/CPU 직약접이어서 처리할 데이터량이 많을 때는 디스크 I/O 까지 발생하므로 쿼리 성능을 좌우한다.

**부분범위 처리를 불가**능하게 함으로써 OLTP 환경에서 애플리케이션 성능을 저하시키는 주요인이 된다.

- 소트가 발생하지 않으면 좋다.
- 소트가 발생하면 메모리 내에서 수행하도록 하면 좋다.

## 5.1.2 소트 오퍼레이션

### 1. Sort Aggregate

- 전체 로우를 대상으로 집계를 수행한다.
- 실제 정렬이 일어나진 않는다.
- Sort Area를 사용한다.

Sort Aggregate 절차

1. SUM, MAX, MIN, COUNT 값을 위한 변수를 하나씩 할당한다.
2. 레코드에서 읽은 값을 각각 변수에 저장한다.
3. 레코드를 읽어가며 해당 변수에 맞게 값을 변경한다.
4. 레코드를 전부 읽고 나서 각 변수에 남은 값을 출력한다.

### 2. Sort Order By

- 데이터를 정렬할 때 나타난다.

### 3. Sort Group By

- 소팅 알고리즘을 사용해 그룹별 집계를 수행할 때 나타난다.
- Group 별로 따로 변수를 선언해 Sort Aggregate 방식처럼 레코드를 모두 읽고 갱신한다.
- Group의 수가 많지 않다면 Sort Area가 클 필요가 전혀 없다.

Hash Group By

- 오라클 10gR2 버전에 도입
- Group By 뒤에 Order By 절을 명시하지 않으면 대부분 Hash Group By로 처리한다.
- 9i부터 그루핑 결과는 정렬 순서를 보장하지 않는다.
    - 오라클은 물리적인 정렬 순서로 읽기 때문이다.
    - 정렬된 순서를 얻고자 한다면 반드시 Order By를 명시하자

### 4. Sort Unique

- 서브쿼리를 풀어 Unnesting할 때 메인 쿼리와의 중복 코드를 제거하는 것
- 서브쿼리의 조인 컬럼에 Unique 인덱스가 없으면 Sort Unique 오퍼레이션이 나타난다.
- PK/Unique 제약 또는 Unique 인덱스를 통해 Unnesting된 서브쿼리의 유일성이 보장되면 Sort Unique는 생략된다.
- Union, Minus, Interest, Distinct 와 같은 연산자를 사용할 때도 다음 오퍼레이션이 나타난다.
    - Distinct 연산에도 Hash Unique 방식을 사용한다.

### 5. Sort Join

- 소트 머지조인을수행할 때 나타난다.

### 6. Window Sort

- 윈도우 함수를 수행할 때 나타난다.

# 5.2 소트가 발생하지 않도록 SQL 작성

소트 연산은 꼭 필요할 때만 사용해야 한다.

Union, Minus, Distinct 연산자는 중복 제거를 위해 소트 연산을 하므로 잘 생각해야 한다.

## 5.2.1 Union vs Union All

Union을 사용하면 중복 제거를 위해 소트 작업을 수행한다.

Union All은 중복 제거를 안해서 소트 작업을 수행하지 않는다. (되도록이면 이거 사용)

Union → Union All로 변경할 때  결과집합이 달라질 수 있어 주의해야 한다.

- 두 집합이 상호배타적이면 변함 없음
- 중복 조건이 있다면 쿼리를 약간 변경해주어야 한다.
    
    ```jsx
    select *
    from A
    where column1 = 조건1
    union all
    select *
    from A
    where column2 = 조건2
    and column1 <> 조건1 or column1 is null
    ```
    

## 5.2.2 Exists 활용

Distinct는 해당하는 데이터를 모두 읽어서 중복을 제거한다. (I/O 많음)

예를들어 (상품번호, 계약일자) 인덱스가 있을 때 다음 쿼리를 보자

```jsx
select DISTINCT 상품번호, 상품명, ...
from 상품, 계약
where 상품.상품유형코드 = :상품코드
and 상품.상품번호 = 계약.상품번호
and 계약.계약일자 between :a and :b
and 계약.계약구분코드 = :계약구분코드
```

위 쿼리는 상품유형코드를 만족하는 상품에 대해 전 계약일자 데이터를 모두 읽는다.

쿼리를 다음과 같이 변경하면 조건절의 모든 데이터를 읽지 않는다.

```jsx
select 상품번호, 상품명, ...
from 상품
where 상품.상품유형코드 = :상품코드
and EXISTS (select 'x' from 계약
						where 상품.상품번호 = 계약.상품번호
						and 계약.계약일자 between :a and :b
						and 계약.계약구분코드 = :계약구분코드)
```

위 쿼리는 다음 조건에 맞는 결과가 있는지 확인하고, 부분처리도 가능할 수 있게 해준다.

Distinct, Minus는 대부분 Exists 서브쿼리로 변환 가능하다.

Minus 튜닝 사례

```jsx
select *
from 관제진행상황
where 상황코드 = '0001'
and 관제일지 between :a and :b
MINUS
select *
from 관제진행상황, 구조활동
where 상황코드 ='0001'
and 관제일시 between :a and :b
and 출동센터id = :출동
and 상황접수번호 = :상황
order by 상황접수번호, 관제일시
```

Not Exists로 변환한다.

```jsx
select *
from 관제진행상황
where 상황코드 = '0001'
and 관제일시 between :a and :b
and not exists (select 'x' from 구조활동
								where 출동센터id = :출동
								and 상황접수번호 = :상황)
order by 상황접수번호, 관제일시
```

## 5.2.3 조인 방식 변경

Hash 조인 + Sort연산은 비효율적이기 때문에 NL조인으로 변경하여 Sort 연산을 생략할 수 있다.
